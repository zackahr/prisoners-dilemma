in gamePage when I receive 400 bad request I receive the message too I wanna show him the message and then give him 3 second and redirect him to /ultimatum I mean when I have two tabs in the same browser so it's the same fingerprint the back end is correct this is the views.py : from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from django.shortcuts import render
import json
import uuid
import traceback

from .models import UltimatumGameRound

def get_client_ip(request):
    """Helper function to get the real client IP address"""
    x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')
    if x_forwarded_for:
        ip = x_forwarded_for.split(',')[0]
    else:
        ip = request.META.get('REMOTE_ADDR')
    return ip

@csrf_exempt
def create_match(request):
    """Create or join an Ultimatum Game match"""
    if request.method != 'POST':
        return JsonResponse({'status': 'error', 'message': 'Invalid request method'}, status=405)

    try:
        data = json.loads(request.body)
    except json.JSONDecodeError:
        return JsonResponse({'status': 'error', 'message': 'Invalid JSON'}, status=400)

    game_mode = data.get('game_mode', 'online')
    player_fingerprint = data.get('player_fingerprint')

    if not player_fingerprint:
        return JsonResponse({'status': 'error', 'message': 'Player fingerprint is required'}, status=400)

    ip_address = get_client_ip(request)
    print(f"[create_match] incoming payload: game_mode={game_mode}, "
          f"player_fingerprint={player_fingerprint}, IP={ip_address}")

    try:
        if game_mode == 'online':
            existing_round = UltimatumGameRound.objects.filter(
                game_mode='online',
                player_2_fingerprint__isnull=True,
                match_complete=False,
                round_number=1
            ).first()

            if existing_round and existing_round.player_1_fingerprint == player_fingerprint:
                return JsonResponse({
                    "status": "error",
                    "message": "You are already registered in this match."
                }, status=400)

            if existing_round:
                # Join the existing match
                existing_round.player_2_fingerprint = player_fingerprint
                existing_round.player_2_country = 'Unknown'
                existing_round.player_2_city = 'Unknown'
                existing_round.player_2_ip_address = ip_address  # Store IP for player 2
                existing_round.save()

                match_id = existing_round.game_match_uuid
                print(f"[create_match] joined existing match {match_id}")
                return JsonResponse({
                    'status': 'joined_existing_match',
                    'match_id': match_id,
                    'game_mode': existing_round.game_mode,
                    'player_1_fingerprint': existing_round.player_1_fingerprint,
                    'player_2_fingerprint': existing_round.player_2_fingerprint,
                })

            else:
                # Create a brand-new match
                match_id = str(uuid.uuid4())[:8]
                new_round = UltimatumGameRound.objects.create(
                    game_match_uuid=match_id,
                    round_number=1,
                    game_mode=game_mode,
                    player_1_fingerprint=player_fingerprint,
                    player_1_country='Unknown',
                    player_1_city='Unknown',
                    player_1_ip_address=ip_address  # Store IP for player 1
                )
                print(f"[create_match] created new match {match_id}")
                return JsonResponse({
                    'status': 'created_new_match',
                    'match_id': match_id,
                    'game_mode': new_round.game_mode,
                    'player_1_fingerprint': new_round.player_1_fingerprint,
                    'player_2_fingerprint': new_round.player_2_fingerprint,
                })

        elif game_mode == 'bot':
            match_id = str(uuid.uuid4())[:8]
            new_round = UltimatumGameRound.objects.create(
                game_match_uuid=match_id,
                round_number=1,
                game_mode=game_mode,
                player_1_fingerprint=player_fingerprint,
                player_1_country='Unknown',
                player_1_city='Unknown',
                player_1_ip_address=ip_address,  # Store IP for player 1
                player_2_fingerprint='bot',
                player_2_country='Bot',
                player_2_city='Bot',
                player_2_ip_address=None  # Bot doesn't have an IP
            )
            print(f"[create_match] created bot match {match_id}")
            return JsonResponse({
                'status': 'created_bot_match',
                'match_id': match_id,
                'game_mode': new_round.game_mode,
                'player_1_fingerprint': new_round.player_1_fingerprint,
                'player_2_fingerprint': new_round.player_2_fingerprint,
            })

        else:
            return JsonResponse({'status': 'error', 'message': 'Invalid game mode'}, status=400)

    except Exception as e:
        print("[create_match] Exception occurred:")
        traceback.print_exc()
        return JsonResponse({'status': 'error', 'message': f'Database error: {str(e)}'}, status=500)

# Rest of your views remain the same...
def game_page(request, match_id):
    """Render the game page for a specific match"""
    try:
        # Check if match exists
        match_exists = UltimatumGameRound.objects.filter(
            game_match_uuid=match_id
        ).exists()
        
        if not match_exists:
            return render(request, 'ultimatum_game/error.html', {
                'error_message': 'Match not found'
            })
        
        # Get match info
        first_round = UltimatumGameRound.objects.filter(
            game_match_uuid=match_id,
            round_number=1
        ).first()
        
        context = {
            'match_id': match_id,
            'game_mode': first_round.game_mode if first_round else 'online',
            'websocket_url': f'ws://localhost:8000/ws/ultimatum-game/{match_id}/',
        }
        
        return render(request, 'ultimatum_game/game.html', context)
        
    except Exception as e:
        return render(request, 'ultimatum_game/error.html', {
            'error_message': f'Error loading game: {str(e)}'
        })

def match_history(request, match_id):
    """Get the history of a specific match"""
    try:
        # Updated to use new field names
        rounds = UltimatumGameRound.objects.filter(
            game_match_uuid=match_id,
            player_1_coins_to_offer__isnull=False,
            player_2_coins_to_offer__isnull=False,
            player_1_response_to_p2_offer__isnull=False,
            player_2_response_to_p1_offer__isnull=False
        ).order_by('round_number')
        
        if not rounds.exists():
            return JsonResponse({
                'status': 'error',
                'message': 'No completed rounds found for this match'
            }, status=404)
        
        history = []
        for round_obj in rounds:
            history.append({
                'round_number': round_obj.round_number,
                'player_1_coins_to_keep': round_obj.player_1_coins_to_keep,
                'player_1_coins_to_offer': round_obj.player_1_coins_to_offer,
                'player_2_coins_to_keep': round_obj.player_2_coins_to_keep,
                'player_2_coins_to_offer': round_obj.player_2_coins_to_offer,
                'player_1_response_to_p2': round_obj.player_1_response_to_p2_offer,
                'player_2_response_to_p1': round_obj.player_2_response_to_p1_offer,
                'player_1_earned': round_obj.player_1_coins_made_in_round,
                'player_2_earned': round_obj.player_2_coins_made_in_round,
                'player_1_cumulative': round_obj.round_player_1_cumulative_score,
                'player_2_cumulative': round_obj.round_player_2_cumulative_score,
                'round_start': round_obj.round_start,
                'round_end': round_obj.round_end,
            })
        
        # Get final match statistics
        last_round = rounds.last()
        
        return JsonResponse({
            'status': 'success',
            'match_id': match_id,
            'game_mode': last_round.game_mode,
            'total_rounds': rounds.count(),
            'match_complete': last_round.match_complete,
            'player_1_final_score': last_round.player_1_final_score,
            'player_2_final_score': last_round.player_2_final_score,
            'match_acceptance_rate': last_round.match_acceptance_rate,
            'match_average_offer': last_round.match_average_offer,
            'history': history
        })
        
    except Exception as e:
        return JsonResponse({
            'status': 'error',
            'message': f'Error retrieving match history: {str(e)}'
        }, status=500)

def match_stats(request, match_id):
    """Get statistics for a specific match - handles both active and completed matches"""
    try:
        # Get the first round to get basic match info
        first_round = UltimatumGameRound.objects.filter(
            game_match_uuid=match_id,
            round_number=1
        ).first()
        
        if not first_round:
            return JsonResponse({
                'status': 'error',
                'message': 'Match not found'
            }, status=404)
        
        # Count players
        players_count = 1  # Player 1 always exists
        if first_round.player_2_fingerprint:
            players_count = 2
        
        # Check if match is ready (has 2 players or is bot mode)
        is_ready = (
            players_count == 2 or 
            first_round.game_mode == 'bot'
        )
        
        # Get completed rounds using new field names
        completed_rounds = UltimatumGameRound.objects.filter(
            game_match_uuid=match_id,
            player_1_coins_to_offer__isnull=False,
            player_2_coins_to_offer__isnull=False,
            player_1_response_to_p2_offer__isnull=False,
            player_2_response_to_p1_offer__isnull=False
        ).order_by('round_number')
        
        completed_count = completed_rounds.count()
        
        # Basic response for active matches
        response_data = {
            'status': 'success',
            'match_id': match_id,
            'game_mode': first_round.game_mode,
            'players_count': players_count,
            'is_ready': is_ready,
            'waiting_for_player_2': first_round.player_2_fingerprint is None and first_round.game_mode == 'online',
            'match_complete': first_round.match_complete,
            'completed_rounds': completed_count,
            'total_rounds': 25,
            'player_1_fingerprint': first_round.player_1_fingerprint,
            'player_2_fingerprint': first_round.player_2_fingerprint,
        }
        
        if completed_rounds.exists():
            last_round = completed_rounds.last()
            
            total_responses = 0
            total_accepts = 0
            
            for round_obj in completed_rounds:
                if round_obj.player_1_response_to_p2_offer:
                    total_responses += 1
                    if round_obj.player_1_response_to_p2_offer == 'accept':
                        total_accepts += 1
                
                if round_obj.player_2_response_to_p1_offer:
                    total_responses += 1
                    if round_obj.player_2_response_to_p1_offer == 'accept':
                        total_accepts += 1
            
            acceptance_rate = (total_accepts / total_responses * 100) if total_responses > 0 else 0
            
            # Calculate offer statistics using new field names
            all_offers = []
            for round_obj in completed_rounds:
                if round_obj.player_1_coins_to_offer is not None:
                    all_offers.append(round_obj.player_1_coins_to_offer)
                if round_obj.player_2_coins_to_offer is not None:
                    all_offers.append(round_obj.player_2_coins_to_offer)
            
            min_offer = min(all_offers) if all_offers else 0
            max_offer = max(all_offers) if all_offers else 0
            avg_offer = sum(all_offers) / len(all_offers) if all_offers else 0
            
            # Player-specific statistics using new field names
            p1_offers = [r.player_1_coins_to_offer for r in completed_rounds if r.player_1_coins_to_offer is not None]
            p2_offers = [r.player_2_coins_to_offer for r in completed_rounds if r.player_2_coins_to_offer is not None]
            
            p1_average_offer = sum(p1_offers) / len(p1_offers) if p1_offers else 0
            p2_average_offer = sum(p2_offers) / len(p2_offers) if p2_offers else 0
            
            # Player response rates (how often their offers are accepted)
            p1_offers_accepted = sum(1 for r in completed_rounds 
                                   if r.player_1_coins_to_offer is not None and r.player_2_response_to_p1_offer == 'accept')
            p2_offers_accepted = sum(1 for r in completed_rounds 
                                   if r.player_2_coins_to_offer is not None and r.player_1_response_to_p2_offer == 'accept')
            
            p1_acceptance_rate = (p1_offers_accepted / len(p1_offers) * 100) if p1_offers else 0
            p2_acceptance_rate = (p2_offers_accepted / len(p2_offers) * 100) if p2_offers else 0
            
            # Add detailed stats to response
            response_data.update({
                'accepted_responses': total_accepts,
                'rejected_responses': total_responses - total_accepts,
                'overall_acceptance_rate': acceptance_rate,
                'overall_average_offer': avg_offer,
                'min_offer': min_offer,
                'max_offer': max_offer,
                'player_1_final_score': last_round.player_1_final_score,
                'player_2_final_score': last_round.player_2_final_score,
                'player_1_acceptance_rate': p1_acceptance_rate,
                'player_2_acceptance_rate': p2_acceptance_rate,
                'player_1_average_offer': p1_average_offer,
                'player_2_average_offer': p2_average_offer,
                'match_completed_at': last_round.match_completed_at,
            })
        
        return JsonResponse(response_data)
        
    except Exception as e:
        print(f"[match_stats] Error: {str(e)}")
        traceback.print_exc()
        return JsonResponse({
            'status': 'error',
            'message': f'Error retrieving match statistics: {str(e)}'
        }, status=500)

def active_matches(request):
    """Get list of active (incomplete) matches"""
    try:
        active_matches = UltimatumGameRound.objects.filter(
            match_complete=False,
            round_number=1
        ).order_by('-row_number')
        
        matches_data = []
        for match in active_matches:
            completed_rounds = UltimatumGameRound.get_completed_rounds_count(match.game_match_uuid)
            
            matches_data.append({
                'match_id': match.game_match_uuid,
                'game_mode': match.game_mode,
                'player_1_fingerprint': match.player_1_fingerprint,
                'player_2_fingerprint': match.player_2_fingerprint,
                'waiting_for_player_2': match.player_2_fingerprint is None,
                'completed_rounds': completed_rounds,
                'created_at': match.round_start,
            })
        
        return JsonResponse({
            'status': 'success',
            'active_matches': matches_data,
            'total_active': len(matches_data)
        })
        
    except Exception as e:
        return JsonResponse({
            'status': 'error',
            'message': f'Error retrieving active matches: {str(e)}'
        }, status=500)

def home(request):
    """Home page for the Ultimatum Game"""
    return render(request, 'ultimatum_game/home.html')

def rules(request):
    """Rules page explaining the Ultimatum Game"""
    return render(request, 'ultimatum_game/rules.html')

@csrf_exempt
def cleanup_matches(request):
    """Admin endpoint to cleanup incomplete matches"""
    if request.method == 'POST':
        try:
            from .game_logic import cleanup_incomplete_matches
            deleted_count = cleanup_incomplete_matches()
            
            return JsonResponse({
                'status': 'success',
                'message': f'Cleaned up {deleted_count} incomplete matches'
            })
            
        except Exception as e:
            return JsonResponse({
                'status': 'error',
                'message': f'Error during cleanup: {str(e)}'
            }, status=500)
    
    return JsonResponse({
        'status': 'error',
        'message': 'Invalid request method'
    }, status=405) and the front end must be updated and show him pop up and then redirect him to /ultimatum because he is already playing so must go to the tab that he play on it this is my code gameApi.js : const API_BASE_URL = "http://localhost:8001/api/ultimatum"

export const gameApi = {
  async createMatch(gameMode, playerFingerprint) {
    console.log("🎮 Creating match:", { gameMode, playerFingerprint })

    try {
      const response = await fetch(`${API_BASE_URL}/create-match-ultimatum/`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          game_mode: gameMode,
          player_fingerprint: playerFingerprint,
        }),
      })

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`)
      }

      const data = await response.json()
      console.log("✅ Match created/joined:", data)
      return data
    } catch (error) {
      console.error("❌ Error creating match:", error)
      throw error
    }
  },

  async getMatchStats(matchId) {
    console.log("📊 Getting match stats for:", matchId)

    try {
      const response = await fetch(`${API_BASE_URL}/match-stats/${matchId}/`)

      if (!response.ok) {
        if (response.status === 404) {
          console.log("⚠️ Match not found")
          throw new Error("Match not found")
        }
        throw new Error(`HTTP error! status: ${response.status}`)
      }

      const data = await response.json()
      console.log("📊 Match stats:", data)
      return data
    } catch (error) {
      console.error("❌ Error getting match stats:", error)
      throw error
    }
  },

  async getMatchHistory(matchId) {
    console.log("📜 Getting match history for:", matchId)

    try {
      const response = await fetch(`${API_BASE_URL}/match-history/${matchId}/`)

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`)
      }

      const data = await response.json()
      console.log("📜 Match history:", data)
      return data
    } catch (error) {
      console.error("❌ Error getting match history:", error)
      throw error
    }
  },
}

export const generatePlayerFingerprint = () => {
  const timestamp = Date.now()
  const random = Math.random().toString(36).substring(2, 15)
  const fingerprint = `player_${timestamp}_${random}`
  console.log("👤 Generated player fingerprint:", fingerprint)
  return fingerprint
}

export const getPlayerFingerprint = () => {
  const storageKey = 'ultimatum_player_fingerprint'
  
  let fingerprint = localStorage.getItem(storageKey)
  
  if (!fingerprint) {
    fingerprint = generatePlayerFingerprint()
    localStorage.setItem(storageKey, fingerprint)
    console.log("💾 Saved new fingerprint to localStorage:", fingerprint)
  } else {
    console.log("🔄 Using existing fingerprint from localStorage:", fingerprint)
  }
  
  return fingerprint
}

export const clearPlayerFingerprint = () => {
  const storageKey = 'ultimatum_player_fingerprint'
  localStorage.removeItem(storageKey)
  console.log("🗑️ Cleared player fingerprint from localStorage")
} and this is useWebSocket.js : import { useState, useEffect, useRef, useCallback } from "react"

export const useWebSocket = (matchId, playerFingerprint) => {
  const [socket, setSocket] = useState(null)
  const [gameState, setGameState] = useState(null)
  const [connectionStatus, setConnectionStatus] = useState("disconnected")
  const [error, setError] = useState(null)
  const [matchTerminated, setMatchTerminated] = useState(false)
  const reconnectTimeoutRef = useRef(null)
  const reconnectAttemptsRef = useRef(0)
  const connectionRef = useRef(null)
  const maxReconnectAttempts = 5
  const OFFER_TIME_LIMIT = 15;
  const [terminationReason, setTerminationReason]   = useState(null);  // NEW

  const connect = useCallback(() => {
    if (!matchId || !playerFingerprint) {
      console.log("❌ Cannot connect: missing matchId or playerFingerprint")
      return
    }

    if (matchTerminated) {
      console.log("❌ Match was terminated - not reconnecting")
      return
    }

    if (connectionRef.current === "connecting" || connectionRef.current === "connected") {
      console.log("⚠️ Connection already in progress or established")
      return
    }

    if (reconnectTimeoutRef.current) {
      clearTimeout(reconnectTimeoutRef.current)
      reconnectTimeoutRef.current = null
    }

    try {
      const wsUrl = `ws://localhost:8001/ws/ultimatum-game/${matchId}/`
      console.log("🔌 Connecting to WebSocket:", wsUrl)
      console.log("👤 Player fingerprint:", playerFingerprint)

      connectionRef.current = "connecting"
      setConnectionStatus("connecting")
      
      const ws = new WebSocket(wsUrl)

      ws.onopen = () => {
        console.log("✅ WebSocket connected successfully")
        setConnectionStatus("connected")
        connectionRef.current = "connected"
        setError(null)
        reconnectAttemptsRef.current = 0

        const joinMessage = {
          action: "join",
          player_fingerprint: playerFingerprint,
        }
        console.log("📤 Sending join message:", joinMessage)
        ws.send(JSON.stringify(joinMessage))
      }

      ws.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data)
          console.log("📥 Received WebSocket message:", data)

          if (data.match_terminated) {
            console.log("🚫 Match terminated:", data.reason)
            setMatchTerminated(true)
            setError(`Match ended: ${data.reason}`)
            reconnectAttemptsRef.current = maxReconnectAttempts
            setTerminationReason(data.reason);
            return
          }

          if (data.error) {
            console.error("❌ Server error:", data.error)
            setError(data.error)
            
            const criticalErrors = ["full", "already started", "Cannot join match"]
            if (criticalErrors.some(err => data.error.includes(err))) {
              reconnectAttemptsRef.current = maxReconnectAttempts
            }
            return
          }

          if (data.game_state) {
            console.log("🎮 Game state update:", data.game_state)
            setGameState(data.game_state)
            
            if (data.game_state && !data.game_state.error) {
              setError(null)
            }
          }

          if (data.game_over) {
            console.log("🏁 Game over:", data)
            setGameState((prev) => ({
              ...prev,
              gameOver: true,
              player1Score: data.player1_score || 0,
              player2Score: data.player2_score || 0,
            }))
          }

          // Handle simultaneous game actions - UPDATED for new field names
          if (data.action) {
            console.log("🎯 Player action:", data)
            setGameState((prev) => {
              if (!prev) return prev

              const updated = { ...prev }

              if (data.action === "make_offer") {
                // Update the appropriate player's offer in current round state
                if (data.player_fingerprint === prev.player1Fingerprint) {
                  updated.currentRoundState = {
                    ...updated.currentRoundState,
                    player1OfferMade: true,
                    player1CoinsToKeep: data.coins_to_keep,
                    player1CoinsToOffer: data.coins_to_offer,
                    // Keep legacy field for backward compatibility
                    player1Offer: data.coins_to_offer,
                  }
                } else if (data.player_fingerprint === prev.player2Fingerprint) {
                  updated.currentRoundState = {
                    ...updated.currentRoundState,
                    player2OfferMade: true,
                    player2CoinsToKeep: data.coins_to_keep,
                    player2CoinsToOffer: data.coins_to_offer,
                    // Keep legacy field for backward compatibility
                    player2Offer: data.coins_to_offer,
                  }
                }
                console.log("💰 Offer made:", {
                  coinsToKeep: data.coins_to_keep,
                  coinsToOffer: data.coins_to_offer,
                  player: data.player_fingerprint
                })
              }

              if (data.action === "respond_to_offer") {
                // Update the appropriate response based on target_player
                if (data.player_fingerprint === prev.player1Fingerprint && data.target_player === "player_2") {
                  updated.currentRoundState = {
                    ...updated.currentRoundState,
                    player1ResponseMade: true,
                    player1Response: data.response,
                  }
                } else if (data.player_fingerprint === prev.player2Fingerprint && data.target_player === "player_1") {
                  updated.currentRoundState = {
                    ...updated.currentRoundState,
                    player2ResponseMade: true,
                    player2Response: data.response,
                  }
                }
                console.log("🤔 Response made:", data.response, "by player:", data.player_fingerprint, "to:", data.target_player)
              }

              return updated
            })
          }
        } catch (err) {
          console.error("❌ Error parsing WebSocket message:", err, event.data)
        }
      }

      ws.onclose = (event) => {
        console.log("🔌 WebSocket closed:", event.code, event.reason)
        setConnectionStatus("disconnected")
        connectionRef.current = "disconnected"
        setSocket(null)

        if (event.code === 4004) {
          setError("Match not found")
          console.log("🚫 Match not found - not attempting to reconnect")
          return
        }

        if (event.code === 4001) {
          setError("Match terminated by server")
          setMatchTerminated(true)
          setTerminationReason(event.reason || "timeout");
          console.log("🚫 Match terminated by server - not attempting to reconnect")
          return
        }

        if (matchTerminated) {
          console.log("🚫 Match terminated - not attempting to reconnect")
          return
        }

        if (event.code === 1000 || reconnectAttemptsRef.current >= maxReconnectAttempts) {
          console.log("🚫 Not attempting to reconnect")
          return
        }

        const delay = Math.min(1000 * Math.pow(2, reconnectAttemptsRef.current), 10000)
        console.log(
          `🔄 Attempting to reconnect in ${delay}ms (attempt ${reconnectAttemptsRef.current + 1}/${maxReconnectAttempts})`
        )

        reconnectTimeoutRef.current = setTimeout(() => {
          reconnectAttemptsRef.current++
          connectionRef.current = "disconnected"
          connect()
        }, delay)
      }

      ws.onerror = (error) => {
        console.error("❌ WebSocket error:", error)
        setConnectionStatus("error")
        connectionRef.current = "error"
        
        if (error.code === "ECONNREFUSED") {
          setError("Cannot connect to game server")
        }
      }

      setSocket(ws)
    } catch (err) {
      console.error("❌ Failed to create WebSocket connection:", err)
      setError("Failed to connect to game server")
      setConnectionStatus("error")
      connectionRef.current = "error"
    }
  }, [matchId, playerFingerprint, matchTerminated])

  const disconnect = useCallback(() => {
    console.log("🔌 Disconnecting WebSocket")
    
    if (reconnectTimeoutRef.current) {
      clearTimeout(reconnectTimeoutRef.current)
      reconnectTimeoutRef.current = null
    }
    
    connectionRef.current = "disconnected"
    reconnectAttemptsRef.current = maxReconnectAttempts
    
    if (socket && socket.readyState !== WebSocket.CLOSED) {
      socket.close(1000, "Manual disconnect")
    }
    
    setSocket(null)
    setConnectionStatus("disconnected")
  }, [socket])

  const sendMessage = useCallback(
    (message) => {
      if (matchTerminated) {
        console.log("❌ Cannot send message: match terminated")
        return false
      }

      if (socket && socket.readyState === WebSocket.OPEN) {
        console.log("📤 Sending message:", message)
        socket.send(JSON.stringify(message))
        return true
      } else {
        console.error("❌ Cannot send message: WebSocket not connected")
        setError("Not connected to game server")
        return false
      }
    },
    [socket, matchTerminated],
  )

  useEffect(() => {
    if (matchId && playerFingerprint && !matchTerminated) {
      connect()
    }
    
    return () => {
      disconnect()
    }
  }, [matchId, playerFingerprint, matchTerminated])

  return {
    socket,
    gameState,
    connectionStatus,
    error,
    matchTerminated,
    terminationReason,
    sendMessage,
    connect,
    disconnect,
  }
} and this is GamePage.jsx : import { useState, useEffect, useCallback } from "react"
import {
  Clock,
  DollarSign,
  CheckCircle,
  XCircle,
  Wifi,
  WifiOff,
  Loader2,
  AlertTriangle,
} from "lucide-react"
import { useNavigate, useSearchParams } from "react-router-dom"

import PayoffsTable from "./PayoffsTable"
import { useWebSocket } from "../hooks/useWebSocket"
import { gameApi, getPlayerFingerprint } from "../services/gameApi"
import "./GamePage.css"

const MAX_ROUNDS = 25
const TOTAL_MONEY = 100
const OFFER_TIME_LIMIT = 25

export default function GamePage() {
  const navigate = useNavigate()
  const [searchParams] = useSearchParams()

  const gameMode = searchParams.get("mode") || "online"
  const urlMatchId = searchParams.get("match") || null

  const [playerFingerprint] = useState(() => getPlayerFingerprint())
  const [matchId, setMatchId] = useState(urlMatchId)
  const [isInitializing, setIsInitializing] = useState(true)

  // Game state for simultaneous play - UPDATED to use coins_to_offer
  const [inputOffer, setInputOffer] = useState("")
  const [timeLeft, setTimeLeft] = useState(OFFER_TIME_LIMIT)
  const [currentPhase, setCurrentPhase] = useState("waiting") // "waiting" | "offering" | "responding" | "result"
  
  // Timeout popup state
  const [showTimeoutPopup, setShowTimeoutPopup] = useState(false)
  const [timeoutCountdown, setTimeoutCountdown] = useState(3)

  const {
    gameState, connectionStatus, error,
    matchTerminated, terminationReason,
    sendMessage
  } = useWebSocket(matchId, playerFingerprint);

  // Initialize match
  useEffect(() => {
    const initializeMatch = async () => {
      if (urlMatchId) {
        console.log("🔗 Using existing match from URL:", urlMatchId)
        console.log("👤 Using fingerprint:", playerFingerprint)
        setMatchId(urlMatchId)
        setIsInitializing(false)
        return
      }

      try {
        console.log("🚀 Initializing new match with mode:", gameMode)
        console.log("👤 Using fingerprint:", playerFingerprint)
        const matchData = await gameApi.createMatch(gameMode, playerFingerprint)
        console.log("✅ Match initialized:", matchData.match_id)
        setMatchId(matchData.match_id)
      } catch (err) {
        console.error("❌ Failed to initialize match:", err)
      } finally {
        setIsInitializing(false)
      }
    }

    initializeMatch()
  }, [gameMode, playerFingerprint, urlMatchId])

  // Handle match termination
  useEffect(() => {
    if (matchTerminated) {
      const t = setTimeout(() => navigate("/ultimatum"), 2000);
      return () => clearTimeout(t);
    }
  }, [matchTerminated, navigate]);

  // Determine current phase based on game state
  useEffect(() => {
    if (!gameState) return

    console.log("🎮 Processing game state update:", gameState)

    if (gameState.gameOver) {
      setCurrentPhase("result")
      return
    }

    if (gameState.waitingForOpponent) {
      setCurrentPhase("waiting")
      return
    }

    const currentRound = gameState.currentRoundState
    if (!currentRound) {
      // First frame of a fresh round → make my offer
      setCurrentPhase("offering")
      setTimeLeft(OFFER_TIME_LIMIT)
      return
    }

    const isPlayer1 = gameState.player1Fingerprint === playerFingerprint
    const isPlayer2 = gameState.player2Fingerprint === playerFingerprint

    // Determine what the current player needs to do
    const myOfferMade = isPlayer1 ? currentRound.player1OfferMade : currentRound.player2OfferMade
    const myResponseMade = isPlayer1 ? currentRound.player1ResponseMade : currentRound.player2ResponseMade
    const opponentOfferMade = isPlayer1 ? currentRound.player2OfferMade : currentRound.player1OfferMade
    const bothOffersMade = currentRound.player1OfferMade && currentRound.player2OfferMade

    console.log("🎯 Phase analysis:", {
      isPlayer1,
      isPlayer2,
      myOfferMade,
      myResponseMade,
      opponentOfferMade,
      bothOffersMade,
      currentRound
    })

    // Priority 1 – make my offer
    if (!myOfferMade) {
      setCurrentPhase("offering")
      setTimeLeft(OFFER_TIME_LIMIT)
      return
    }

    // Priority 2 – respond to opponent
    if (bothOffersMade && !myResponseMade) {
      setCurrentPhase("responding")
      setTimeLeft(OFFER_TIME_LIMIT)
      return
    }
    // Priority 3: Otherwise, I'm waiting
    console.log("🎯 Setting phase to waiting - all my actions complete")
    setCurrentPhase("waiting")
    setTimeLeft(15)
  }, [gameState, playerFingerprint])

  // Handle timeout navigation with popup
  useEffect(() => {
    if (timeLeft <= 0 &&
        (currentPhase === "offering" || currentPhase === "responding")) {
      console.log("⏰ Time's up! Showing timeout popup")
      setShowTimeoutPopup(true)
      setTimeoutCountdown(3)
    }
  }, [timeLeft, currentPhase]);

  // Handle timeout popup countdown
  useEffect(() => {
    if (!showTimeoutPopup) return

    if (timeoutCountdown <= 0) {
      console.log("⏰ Redirecting to /ultimatum")
      navigate("/ultimatum")
      return
    }

    const timer = setTimeout(() => {
      setTimeoutCountdown(prev => prev - 1)
    }, 1000)

    return () => clearTimeout(timer)
  }, [showTimeoutPopup, timeoutCountdown, navigate])

  // Timer countdown
  useEffect(() => {
    if (timeLeft <= 0 || currentPhase === "waiting" || currentPhase === "result") return

    const timer = setTimeout(() => {
      setTimeLeft((prev) => prev - 1)
    }, 1000)
    return () => clearTimeout(timer)
  }, [timeLeft, currentPhase])

  // Submit offer - UPDATED to send coins_to_keep and coins_to_offer
  const submitOffer = useCallback(() => {
    const coinsToOffer = Math.max(0, Math.min(+inputOffer || 0, TOTAL_MONEY))
    const coinsToKeep = TOTAL_MONEY - coinsToOffer
    
    console.log("💰 Submitting offer:", {
      coinsToKeep,
      coinsToOffer,
      total: coinsToKeep + coinsToOffer
    })

    const success = sendMessage({
      action: "make_offer",
      player_fingerprint: playerFingerprint,
      coins_to_keep: coinsToKeep,
      coins_to_offer: coinsToOffer,
    })

    if (success) {
      setInputOffer("")
    }
  }, [inputOffer, sendMessage, playerFingerprint])

  // Respond to offers
  const respondToPlayer = useCallback((targetPlayer, accept) => {
    const response = accept ? "accept" : "reject"
    console.log(`🤔 Responding ${response} to ${targetPlayer}`)

    const success = sendMessage({
      action: "respond_to_offer",
      player_fingerprint: playerFingerprint,
      target_player: targetPlayer,
      response: response,
    })

    return success
  }, [sendMessage, playerFingerprint])

  // Helper to get current player info
  const isPlayer1 = gameState?.player1Fingerprint === playerFingerprint
  const isPlayer2 = gameState?.player2Fingerprint === playerFingerprint

  // Timeout Popup Component
  const TimeoutPopup = () => {
    if (!showTimeoutPopup) return null

    return (
      <div className="timeout-popup-overlay">
        <div className="timeout-popup">
          <div className="timeout-popup-content">
            <AlertTriangle className="timeout-icon" />
            <h2 className="timeout-title">Time's Up!</h2>
            <p className="timeout-message">
              The 25 seconds have passed. You will be redirected to the menu.
            </p>
            <div className="timeout-countdown">
              <div className="countdown-circle">
                <span className="countdown-number">{timeoutCountdown}</span>
              </div>
            </div>
          </div>
        </div>
      </div>
    )
  }

  // Handle match termination UI
  if (matchTerminated) {
    return (
      <div className="game-page">
        <div className="game-container">
          <div className="error-section">
            <XCircle className="error-icon" />
            <h2>Opponent Disconnected</h2>
            <p>
              {terminationReason === "timeout"
                ? "Your opponent ran out of time."
                : "Your opponent left the match."}
            </p>
            <p>You'll be returned to the menu…</p>
          </div>
        </div>
      </div>
    );
  }

  // Show loading spinner
  if (isInitializing || !matchId) {
    return (
      <div className="game-page">
        <div className="game-container">
          <div className="loading-section">
            <Loader2 className="loading-spinner" />
            <p>Initializing game…</p>
          </div>
        </div>
      </div>
    )
  }

  // Connection error
  if (error) {
    return (
      <div className="game-page">
        <div className="game-container">
          <div className="error-section">
            <XCircle className="error-icon" />
            <h2>Connection Error</h2>
            <p>{error}</p>
            <div className="debug-info">
              <p><strong>Your fingerprint:</strong> {playerFingerprint}</p>
              <p><strong>Match ID:</strong> {matchId}</p>
              {gameState && (
                <>
                  <p><strong>Player 1:</strong> {gameState.player1Fingerprint}</p>
                  <p><strong>Player 2:</strong> {gameState.player2Fingerprint}</p>
                  <p><strong>Game Mode:</strong> {gameState.gameMode}</p>
                  <p><strong>Current Round:</strong> {gameState.currentRound}</p>
                  <p><strong>Waiting for Opponent:</strong> {gameState.waitingForOpponent ? "Yes" : "No"}</p>
                  {gameState.currentRoundState && (
                    <>
                      <p><strong>P1 Offer Made:</strong> {gameState.currentRoundState.player1OfferMade ? "Yes" : "No"}</p>
                      <p><strong>P2 Offer Made:</strong> {gameState.currentRoundState.player2OfferMade ? "Yes" : "No"}</p>
                    </>
                  )}
                </>
              )}
            </div>
            <button onClick={() => navigate("/ultimatum")} className="menu-button">
              Back to Menu
            </button>
          </div>
        </div>
      </div>
    )
  }

  // Game over screen
  if (currentPhase === "result" && gameState?.gameOver) {
    return (
      <div className="game-over-page">
        <div className="game-over-container">
          <div className="game-over-header">
            <h1 className="game-over-title">Game Complete!</h1>
            <p>All {MAX_ROUNDS} rounds finished</p>
          </div>

          <div className="final-scores">
            <div className="score-card">
              <h3>Final Scores</h3>
              <div className="scores">
                <div className="score-item">
                  <span>Player 1:</span>
                  <span>${gameState.player1Score}</span>
                </div>
                <div className="score-item">
                  <span>Player 2:</span>
                  <span>${gameState.player2Score}</span>
                </div>
                <div className="score-item">
                  <span>Your Score:</span>
                  <span>${isPlayer1 ? gameState.player1Score : gameState.player2Score}</span>
                </div>
                <div className="score-item">
                  <span>Opponent Score:</span>
                  <span>${isPlayer1 ? gameState.player2Score : gameState.player1Score}</span>
                </div>
              </div>
            </div>
          </div>

          <div className="action-buttons">
            <button onClick={() => navigate("/ultimatum")} className="menu-button">
              Back to Menu
            </button>
          </div>

          {/* <PayoffsTable history={gameState.roundHistory || []} /> */}
        </div>
      </div>
    )
  }

  // Main game interface
  return (
    <div className="game-page">
      <TimeoutPopup />
      <div className="game-container">
        {/* Connection status */}
        <div className="connection-status">
          {connectionStatus === "connected" ? (
            <>
              <Wifi className="connection-icon connected" /> Connected
            </>
          ) : connectionStatus === "connecting" ? (
            <>
              <Loader2 className="connection-icon connecting" /> Connecting
            </>
          ) : (
            <>
              <WifiOff className="connection-icon disconnected" /> Disconnected
            </>
          )}
        </div>

        {/* Game header */}
        <div className="game-header">
          <h1 className="game-title simultaneous">Ultimatum Game </h1>
          <p className="game-subtitle">
            Round {gameState?.currentRound || 1} of {MAX_ROUNDS}
          </p>
          <p className="match-id">Match ID: {matchId}</p>
          <p className="player-id">You are: {isPlayer1 ? "Player 1" : isPlayer2 ? "Player 2" : "Unknown"}</p>
        </div>

        {/* Main game card */}
        <div className="game-board">
          <div className="game-card">
            <div className="game-card-header">
              <div className="timer">
                <Clock className="timer-icon" />
                <span>{timeLeft}s</span>
              </div>
              <h2 className="phase-title">
                {currentPhase === "offering" && "MAKE YOUR OFFER"}
                {currentPhase === "responding" && "RESPOND TO OFFERS"}
                {currentPhase === "waiting" && "WAITING…"}
                {currentPhase === "result" && "GAME COMPLETE"}
              </h2>
            </div>

            <div className="game-card-content">
              <div className="money-display">
                <div className="money-content">
                  <DollarSign className="money-icon" />
                  <span>{TOTAL_MONEY}</span>
                </div>
              </div>

              {/* Waiting for opponent to join */}
              {gameState?.waitingForOpponent && (
                <div className="waiting-section">
                  <div className="waiting-animation">
                    <Loader2 className="waiting-spinner" />
                    <p className="waiting-text">Waiting for opponent to join…</p>
                  </div>
                  <div className="debug-info">
                    <p><strong>Match ID:</strong> {matchId}</p>
                    <p><strong>Game Mode:</strong> {gameState.gameMode}</p>
                    <p><strong>Player 1:</strong> {gameState.player1Fingerprint || "None"}</p>
                    <p><strong>Player 2:</strong> {gameState.player2Fingerprint || "None"}</p>
                  </div>
                </div>
              )}

              {/* Offering phase - UPDATED to show coins breakdown */}
              {currentPhase === "offering" && !gameState?.waitingForOpponent && (
                <div className="offer-section">
                  <p className="offer-label">How much will you offer your opponent?</p>
                  <div className="offer-breakdown">
                    <p className="breakdown-text">
                      You offer: <strong>${inputOffer || 0}</strong> | 
                      You keep: <strong>${TOTAL_MONEY - (+inputOffer || 0)}</strong>
                    </p>
                  </div>
                  <div className="offer-input-container">
                    <input
                      type="number"
                      value={inputOffer}
                      onChange={(e) => {
                        const value = e.target.value;
                        // Allow empty string for clearing the input
                        if (value === '') {
                          setInputOffer('');
                          return;
                        }
                        
                        // Convert to number and validate
                        const numValue = Number(value);
                        
                        // Only allow values between 0 and TOTAL_MONEY (100)
                        if (!isNaN(numValue) && numValue >= 0 && numValue <= TOTAL_MONEY) {
                          setInputOffer(value);
                        }
                        // If value is greater than TOTAL_MONEY, set it to TOTAL_MONEY
                        else if (!isNaN(numValue) && numValue > TOTAL_MONEY) {
                          setInputOffer(TOTAL_MONEY.toString());
                        }
                      }}
                      min="0"
                      max={TOTAL_MONEY}
                      step="1"
                      placeholder="0"
                      className="offer-input"
                      autoFocus
                      onKeyDown={(e) => {
                        // Prevent entering 'e', 'E', '+', '-' which are valid in number inputs but not wanted here
                        if (['e', 'E', '+', '-'].includes(e.key)) {
                          e.preventDefault();
                        }
                      }}
                    />
                    <div className="dollar-sign">$</div>
                  </div>
                  <button
                    onClick={submitOffer}
                    disabled={!inputOffer || +inputOffer < 0 || +inputOffer > TOTAL_MONEY}
                    className="submit-button"
                  >
                    SUBMIT OFFER
                  </button>
                </div>
              )}

              {/* Responding phase - UPDATED to show new logic */}
              {currentPhase === "responding" && gameState?.currentRoundState && (
                <div className="responding-section">
                  <h3>Respond to Offers:</h3>
                  
                  {/* Response to opponent's offer - UPDATED */}
                  {isPlayer1 && gameState.currentRoundState.player2CoinsToOffer !== null && (
                    <div className="offer-response-card">
                      <div className="offer-display">
                        <p className="offer-label">Player 2 offers you:</p>
                        <p className="offer-amount-large">${gameState.currentRoundState.player2CoinsToOffer}</p>
                        <div className="decision-info">
                          <p className="keep-amount">
                            You always keep: ${gameState.currentRoundState.player1CoinsToKeep || 0}
                          </p>
                          <p className="keep-amount">
                            If you accept: You get ${(gameState.currentRoundState.player1CoinsToKeep || 0) + gameState.currentRoundState.player2CoinsToOffer} total
                          </p>
                          <p className="keep-amount">
                            If you reject: You get ${gameState.currentRoundState.player1CoinsToKeep || 0} total
                          </p>
                        </div>
                      </div>
                      
                      {!gameState.currentRoundState.player1ResponseMade && (
                        <div className="response-buttons">
                          <button
                            onClick={() => respondToPlayer("player_2", true)}
                            className="accept-button"
                          >
                            <CheckCircle className="button-icon" />
                            ACCEPT
                          </button>
                          <button
                            onClick={() => respondToPlayer("player_2", false)}
                            className="reject-button"
                          >
                            <XCircle className="button-icon" />
                            REJECT
                          </button>
                        </div>
                      )}
                      
                      {gameState.currentRoundState.player1ResponseMade && (
                        <p className="response-made">
                          You {gameState.currentRoundState.player1Response}ed this offer
                        </p>
                      )}
                    </div>
                  )}

                  {isPlayer2 && gameState.currentRoundState.player1CoinsToOffer !== null && (
                    <div className="offer-response-card">
                      <div className="offer-display">
                        <p className="offer-label">Player 1 offers you:</p>
                        <p className="offer-amount-large">${gameState.currentRoundState.player1CoinsToOffer}</p>
                        <div className="decision-info">
                          <p className="keep-amount">
                            You always keep: ${gameState.currentRoundState.player2CoinsToKeep || 0}
                          </p>
                          <p className="keep-amount">
                            If you accept: You get ${(gameState.currentRoundState.player2CoinsToKeep || 0) + gameState.currentRoundState.player1CoinsToOffer} total
                          </p>
                          <p className="keep-amount">
                            If you reject: You get ${gameState.currentRoundState.player2CoinsToKeep || 0} total
                          </p>
                        </div>
                      </div>
                      
                      {!gameState.currentRoundState.player2ResponseMade && (
                        <div className="response-buttons">
                          <button
                            onClick={() => respondToPlayer("player_1", true)}
                            className="accept-button"
                          >
                            <CheckCircle className="button-icon" />
                            ACCEPT
                          </button>
                          <button
                            onClick={() => respondToPlayer("player_1", false)}
                            className="reject-button"
                          >
                            <XCircle className="button-icon" />
                            REJECT
                          </button>
                        </div>
                      )}
                      
                      {gameState.currentRoundState.player2ResponseMade && (
                        <p className="response-made">
                          You {gameState.currentRoundState.player2Response}ed this offer
                        </p>
                      )}
                    </div>
                  )}
                </div>
              )}

              {/* Waiting phase */}
              {currentPhase === "waiting" && !gameState?.waitingForOpponent && (
                <div className="waiting-section">
                  <div className="waiting-animation">
                    <Loader2 className="waiting-spinner" />
                    <p className="waiting-text">
                      {!gameState?.currentRoundState?.player1OfferMade || !gameState?.currentRoundState?.player2OfferMade
                        ? "Waiting for all offers to be made…"
                        : "Waiting for all responses…"}
                    </p>
                  </div>
                  
                  {/* Show current round status */}
                  {gameState?.currentRoundState && (
                    <div className="round-status">
                      <p>
                        <span>Offers:</span>
                        <span>
                          {gameState.currentRoundState.player1OfferMade ? "✓" : "⏳"} Player 1, {" "}
                          {gameState.currentRoundState.player2OfferMade ? "✓" : "⏳"} Player 2
                        </span>
                      </p>
                      <p>
                        <span>Responses:</span>
                        <span>
                          {gameState.currentRoundState.player1ResponseMade ? "✓" : "⏳"} Player 1, {" "}
                          {gameState.currentRoundState.player2ResponseMade ? "✓" : "⏳"} Player 2
                        </span>
                      </p>
                    </div>
                  )}
                </div>
              )}
            </div>
          </div>
        </div>

        {/* Scores */}
        {gameState && !gameState.waitingForOpponent && (
          <div className="scores-section">
            <div className="score-item">
              <span>Your Score:</span>
              <span>
                ${isPlayer1 ? gameState.player1Score : gameState.player2Score}
              </span>
            </div>
            <div className="score-item">
              <span>Opponent Score:</span>
              <span>
                ${isPlayer1 ? gameState.player2Score : gameState.player1Score}
              </span>
            </div>
          </div>
        )}

        {/* Game history */}
        {gameState && gameState.roundHistory && gameState.roundHistory.length > 0 && (
          <div className="payoffs-area">
            <PayoffsTable history={gameState.roundHistory || []} />
          </div>
        )}

        {/* Debug info (only in development) */}
        {process.env.NODE_ENV === 'development' && gameState && (
          <div className="debug-info" style={{ marginTop: '2rem' }}>
            <h4>Debug Info:</h4>
            <p><strong>Current Phase:</strong> {currentPhase}</p>
            <p><strong>Is Player 1:</strong> {isPlayer1 ? "Yes" : "No"}</p>
            <p><strong>Is Player 2:</strong> {isPlayer2 ? "Yes" : "No"}</p>
            <p><strong>Connection Status:</strong> {connectionStatus}</p>
            {gameState.currentRoundState && (
              <>
                <p><strong>Round Number:</strong> {gameState.currentRoundState.roundNumber}</p>
                <p><strong>P1 Offer Made:</strong> {gameState.currentRoundState.player1OfferMade ? "Yes" : "No"}</p>
                <p><strong>P2 Offer Made:</strong> {gameState.currentRoundState.player2OfferMade ? "Yes" : "No"}</p>
                <p><strong>P1 Response Made:</strong> {gameState.currentRoundState.player1ResponseMade ? "Yes" : "No"}</p>
                <p><strong>P2 Response Made:</strong> {gameState.currentRoundState.player2ResponseMade ? "Yes" : "No"}</p>
              </>
            )}
          </div>
        )}
      </div>
    </div>
  )
} and this is MatchmakingPage.jsx : import { useState, useEffect, useRef } from "react"
import { Loader2, Wifi, WifiOff, Users } from "lucide-react"
import { useNavigate } from "react-router-dom"
import { gameApi, getPlayerFingerprint } from "../services/gameApi"
import "./MatchmakingPage.css"

export default function MatchmakingPage() {
  const navigate = useNavigate()
  
  // FIXED: Use the new consistent fingerprint function
  const [playerFingerprint] = useState(() => getPlayerFingerprint())
  
  const [matchId, setMatchId] = useState(null)
  const [status, setStatus] = useState("searching") // searching, waiting, found, error
  const [error, setError] = useState(null)
  const pollTimeoutRef = useRef(null)
  const mountedRef = useRef(true)
  const pollAttempts = useRef(0)
  const maxPollAttempts = 15 // 30 seconds max

  useEffect(() => {
    return () => {
      mountedRef.current = false
      if (pollTimeoutRef.current) {
        clearTimeout(pollTimeoutRef.current)
      }
    }
  }, [])

  useEffect(() => {
    const findMatch = async () => {
      if (!mountedRef.current) return
      
      try {
        console.log("🔍 Searching for online match with fingerprint:", playerFingerprint)
        setStatus("searching")

        const matchData = await gameApi.createMatch("online", playerFingerprint)

        if (!mountedRef.current) return

        console.log("✅ Match result:", matchData)
        setMatchId(matchData.match_id)

        if (matchData.status === "joined_existing_match") {
          console.log("🎯 Joined existing match, starting game immediately")
          setStatus("found")
          setTimeout(() => {
            if (mountedRef.current) {
              navigate(`/ultimatum/game?mode=online&match=${matchData.match_id}`)
            }
          }, 1500)
        } else if (matchData.status === "created_new_match") {
          console.log("⏳ Created new match, waiting for opponent")
          setStatus("waiting")
          pollAttempts.current = 0
          checkMatchStatus(matchData.match_id)
        }
      } catch (error) {
        console.error("❌ Error finding match:", error)
        if (mountedRef.current) {
          setError(error.message)
          setStatus("error")
        }
      }
    }

    findMatch()
  }, [navigate, playerFingerprint])

  const checkMatchStatus = async (matchId) => {
    if (!mountedRef.current) return
    
    try {
      pollAttempts.current++
      console.log(`🔄 Checking match status (attempt ${pollAttempts.current}/${maxPollAttempts})`)
      
      const stats = await gameApi.getMatchStats(matchId)
      
      if (!mountedRef.current) return
      
      console.log("📊 Match stats:", stats)
      
      // Check if second player joined
      if (stats.players_count >= 2 || stats.is_ready) {
        console.log("🎯 Opponent found! Starting game...")
        setStatus("found")
        setTimeout(() => {
          if (mountedRef.current) {
            navigate(`/ultimatum/game?mode=online&match=${matchId}`)
          }
        }, 1000)
        return
      }
      
      // Check if we've exceeded max attempts
      if (pollAttempts.current >= maxPollAttempts) {
        console.log("⏰ Timeout reached, proceeding to game anyway...")
        setStatus("found")
        setTimeout(() => {
          if (mountedRef.current) {
            navigate(`/ultimatum/game?mode=online&match=${matchId}`)
          }
        }, 1000)
        return
      }
      
      // Continue polling with exponential backoff
      const delay = Math.min(1000 + (pollAttempts.current * 200), 3000)
      pollTimeoutRef.current = setTimeout(() => {
        checkMatchStatus(matchId)
      }, delay)
      
    } catch (error) {
      console.error("❌ Error checking match status:", error)
      
      // If we get an error, try a few more times then proceed
      if (pollAttempts.current >= 3) {
        console.log("⚠️ Multiple errors, proceeding to game...")
        setStatus("found")
        setTimeout(() => {
          if (mountedRef.current) {
            navigate(`/ultimatum/game?mode=online&match=${matchId}`)
          }
        }, 1000)
        return
      }
      
      // Retry with backoff
      const delay = Math.min(1000 + (pollAttempts.current * 500), 3000)
      pollTimeoutRef.current = setTimeout(() => {
        checkMatchStatus(matchId)
      }, delay)
    }
  }

  const handleCancel = () => {
    console.log("❌ User cancelled matchmaking")
    mountedRef.current = false
    if (pollTimeoutRef.current) {
      clearTimeout(pollTimeoutRef.current)
    }
    navigate("/ultimatum")
  }

  const handleRetry = () => {
    console.log("🔄 Retrying matchmaking")
    if (pollTimeoutRef.current) {
      clearTimeout(pollTimeoutRef.current)
    }
    setError(null)
    setStatus("searching")
    setMatchId(null)
    pollAttempts.current = 0
    // Trigger re-render to restart the effect
    window.location.reload()
  }

  return (
    <div className="matchmaking-page">
      <div className="matchmaking-container">
        <div className="matchmaking-header">
          <h1 className="matchmaking-title">Ultimatum Game</h1>
          <p className="matchmaking-subtitle">Finding an opponent for your online match...</p>
        </div>

        <div className="matchmaking-card">
          <div className="matchmaking-icon-container">
            {status === "searching" || status === "waiting" ? (
              <Loader2 className="matchmaking-spinner" />
            ) : status === "found" ? (
              <div className="matchmaking-success">
                <Users className="success-icon" />
              </div>
            ) : (
              <div className="matchmaking-error">
                <WifiOff className="error-icon" />
              </div>
            )}
          </div>

          <h2 className="matchmaking-status-title">
            {status === "searching" && "Searching for Match..."}
            {status === "waiting" && "Waiting for Opponent..."}
            {status === "found" && "Opponent Found!"}
            {status === "error" && "Connection Error"}
          </h2>

          <p className="matchmaking-status-text">
            {status === "searching" && "Looking for available matches or creating a new one..."}
            {status === "waiting" && `Match created! Waiting for another player to join... (${pollAttempts.current}/${maxPollAttempts})`}
            {status === "found" && "Match found! Starting game..."}
            {status === "error" && (error || "Something went wrong. Please try again.")}
          </p>

          <div className="matchmaking-info">
            <div className="matchmaking-info-row">
              <span>Your ID:</span>
              <span className="matchmaking-player-id">{playerFingerprint}</span>
            </div>
            {matchId && (
              <div className="matchmaking-info-row">
                <span>Match ID:</span>
                <span className="matchmaking-match-id">{matchId}</span>
              </div>
            )}
            <div className="matchmaking-info-row">
              <span>Status:</span>
              <div className="connection-status">
                {status === "searching" || status === "waiting" ? (
                  <>
                    <Loader2 className="connection-icon connection-connecting" />
                    <span className="connection-connecting">{status === "searching" ? "Searching" : "Waiting"}</span>
                  </>
                ) : status === "found" ? (
                  <>
                    <Wifi className="connection-icon connection-connected" />
                    <span className="connection-connected">Ready</span>
                  </>
                ) : (
                  <>
                    <WifiOff className="connection-icon connection-disconnected" />
                    <span className="connection-disconnected">Error</span>
                  </>
                )}
              </div>
            </div>
          </div>

          <div className="matchmaking-buttons">
            {(status === "searching" || status === "waiting") && (
              <button onClick={handleCancel} className="cancel-button">
                Cancel Search
              </button>
            )}
            {status === "error" && (
              <>
                <button onClick={handleRetry} className="retry-button">
                  Try Again
                </button>
                <button onClick={handleCancel} className="cancel-button">
                  Back to Menu
                </button>
              </>
            )}
          </div>
        </div>
      </div>
    </div>
  )
} must show him pop up with the message that send from the back end and redirect him after 3 second