this is asgi.py:
import os
from channels.auth import AuthMiddlewareStack
from channels.routing import ProtocolTypeRouter, URLRouter
from django.core.asgi import get_asgi_application

from the_game.routing import websocket_urlpatterns as pd_ws

from ultimatum.routing import websocket_urlpatterns as ult_ws

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "game.settings")

application = ProtocolTypeRouter({
    "http": get_asgi_application(),
    "websocket": AuthMiddlewareStack(
        URLRouter(
            pd_ws + ult_ws
        )
    ),
})
and this is urls.py:
"""
URL configuration for game project.

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/5.1/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""
from django.contrib import admin
from django.urls import path, include
from django.views.generic import TemplateView

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/prisoners/', include('the_game.urls')),
    path('api/ultimatum/', include('ultimatum.urls')), 
    path('', TemplateView.as_view(template_name='index.html')),
    path('<path:path>', TemplateView.as_view(template_name='index.html')),
]

and this is the backend of my game ultimatum

ultimatum/consumers.py:
import json
import asyncio
import logging
from django.utils import timezone
from channels.generic.websocket import AsyncWebsocketConsumer
from channels.db import database_sync_to_async
from asgiref.sync import sync_to_async
from .models import UltimatumGameRound
from .game_logic import update_game_stats
import random

logger = logging.getLogger(__name__)

class UltimatumGameConsumer(AsyncWebsocketConsumer):

    async def connect(self):
        self.match_id = self.scope["url_route"]["kwargs"]["match_id"]
        self.match_exists = await self.check_match_exists(self.match_id)
        
        if not self.match_exists:
            logger.warning("Match %s not found – closing WS", self.match_id)
            await self.close()
            return

        self.room_group_name = f"ultimatum_game_{self.match_id}"
        await self.channel_layer.group_add(self.room_group_name, self.channel_name)
        await self.accept()

        await self.send(text_data=json.dumps({
            "game_state": await self.get_game_state()
        }))

    async def disconnect(self, code):
        if hasattr(self, "room_group_name"):
            await self.channel_layer.group_discard(self.room_group_name, self.channel_name)

        # Delete incomplete matches on disconnect
        if self.match_exists:
            deleted = await self.delete_incomplete_match()
            if deleted:
                await self.channel_layer.group_send(self.room_group_name, {
                    "type": "game_aborted",
                    "msg": "Match was incomplete and has been deleted."
                })
                logger.info("Incomplete match %s deleted.", self.match_id)

    async def game_aborted(self, event):
        await self.send(text_data=json.dumps({
            "game_aborted": True,
            "message": event["msg"],
        }))

    async def receive(self, text_data):
        data = json.loads(text_data)
        action = data.get("action")
        fp = data.get("player_fingerprint")
        
        if not action or not fp:
            return

        gs = await self.get_game_state()
        if gs["gameOver"]:
            await self.send(text_data=json.dumps({"error": "Game is already over"}))
            return

        # Handle join
        if action == "join":
            if not await self.handle_join(fp):
                await self.send(text_data=json.dumps({"error": "Match is full or already started."}))
                await self.close()
                return
            await self.channel_layer.group_send(self.room_group_name, {
                "type": "game_state_update",
                "game_state": await self.get_game_state(),
            })
            return

        # Handle game actions
        if action == "make_offer":
            offer = data.get("offer")
            if offer is None or not (0 <= offer <= 100):
                await self.send(text_data=json.dumps({"error": "Invalid offer amount"}))
                return

            if not await self.process_offer(fp, offer):
                await self.send(text_data=json.dumps({"error": "You are not the proposer or offer already made"}))
                return

            await self.channel_layer.group_send(self.room_group_name, {
                "type": "game_action",
                "player_fingerprint": fp,
                "action": "make_offer",
                "offer": offer,
            })

        elif action == "respond_to_offer":
            response = data.get("response")
            if response not in ["accept", "reject"]:
                await self.send(text_data=json.dumps({"error": "Invalid response"}))
                return

            if not await self.process_response(fp, response):
                await self.send(text_data=json.dumps({"error": "You are not the responder or response already made"}))
                return

            await self.channel_layer.group_send(self.room_group_name, {
                "type": "game_action",
                "player_fingerprint": fp,
                "action": "respond_to_offer",
                "response": response,
            })

            # Check if round is complete after response
            if await self.check_round_complete():
                await self.calculate_round_results()
                gs = await self.get_game_state()
                await self.channel_layer.group_send(self.room_group_name, {
                    "type": "game_state_update",
                    "game_state": gs,
                })
                
                if gs["gameOver"]:
                    await self.channel_layer.group_send(self.room_group_name, {
                        "type": "game_over",
                        "player1_score": gs["player1Score"],
                        "player2_score": gs["player2Score"],
                    })
                else:
                    # Create next round
                    await self.create_next_round()

        # Handle bot actions
        current_round = await self.get_current_round()
        if current_round and current_round.game_mode == "bot":
            if action == "make_offer" and current_round.current_responder_fingerprint == "bot":
                await asyncio.sleep(0.5)
                await self.make_bot_response()
            elif action == "respond_to_offer" and current_round.current_proposer_fingerprint == "bot":
                await asyncio.sleep(0.5)
                await self.make_bot_offer()

    # Group message handlers
    async def game_action(self, event):
        await self.send(text_data=json.dumps({
            "player_fingerprint": event["player_fingerprint"],
            "action": event["action"],
            "offer": event.get("offer"),
            "response": event.get("response"),
        }))

    async def game_state_update(self, event):
        await self.send(text_data=json.dumps({
            "game_state": event["game_state"]
        }))

    async def game_over(self, event):
        await self.send(text_data=json.dumps({
            "game_over": True,
            "player1_score": event["player1_score"],
            "player2_score": event["player2_score"],
        }))

    # Database helpers
    @database_sync_to_async
    def check_match_exists(self, match_id):
        return UltimatumGameRound.objects.filter(game_match_uuid=match_id).exists()

    @database_sync_to_async
    def delete_incomplete_match(self):
        return UltimatumGameRound.delete_incomplete_match(self.match_id)

    @database_sync_to_async
    def handle_join(self, fp):
        first_round = UltimatumGameRound.objects.filter(
            game_match_uuid=self.match_id, 
            round_number=1
        ).first()
        
        if not first_round or first_round.match_complete:
            return False

        if not first_round.player_1_fingerprint:
            first_round.player_1_fingerprint = fp
            first_round.save()
            return True

        if first_round.player_1_fingerprint == fp:
            return True

        if first_round.game_mode == "online":
            if first_round.player_2_fingerprint in (None, fp):
                if fp == first_round.player_1_fingerprint:
                    return False
                first_round.player_2_fingerprint = fp
                first_round.save()
                return True
        else:  # bot mode
            if first_round.player_2_fingerprint != "bot":
                first_round.player_2_fingerprint = "bot"
                first_round.save()
            return True
        return False

    @database_sync_to_async
    def get_current_round(self):
        rounds = UltimatumGameRound.objects.filter(game_match_uuid=self.match_id).order_by('-round_number')
        return rounds.first()

    @database_sync_to_async
    def process_offer(self, fp, offer):
        current_round = UltimatumGameRound.objects.filter(
            game_match_uuid=self.match_id
        ).order_by('-round_number').first()
        
        if not current_round or current_round.proposer_offer is not None:
            return False

        # Check if this player is the proposer for this round
        if fp != current_round.current_proposer_fingerprint:
            return False

        current_round.proposer_offer = offer
        current_round.save()
        return True

    @database_sync_to_async
    def process_response(self, fp, response):
        current_round = UltimatumGameRound.objects.filter(
            game_match_uuid=self.match_id
        ).order_by('-round_number').first()
        
        if not current_round or current_round.responder_response is not None:
            return False

        # Check if this player is the responder for this round
        if fp != current_round.current_responder_fingerprint:
            return False

        # Check if offer has been made
        if current_round.proposer_offer is None:
            return False

        current_round.responder_response = response
        current_round.save()
        return True

    @database_sync_to_async
    def check_round_complete(self):
        current_round = UltimatumGameRound.objects.filter(
            game_match_uuid=self.match_id
        ).order_by('-round_number').first()
        
        if not current_round:
            return False
            
        return (current_round.proposer_offer is not None and 
                current_round.responder_response is not None)

    @database_sync_to_async
    def calculate_round_results(self):
        current_round = UltimatumGameRound.objects.filter(
            game_match_uuid=self.match_id
        ).order_by('-round_number').first()
        
        if current_round:
            update_game_stats(self.match_id, current_round.round_number)

    @database_sync_to_async
    def create_next_round(self):
        current_round = UltimatumGameRound.objects.filter(
            game_match_uuid=self.match_id
        ).order_by('-round_number').first()
        
        if current_round and current_round.round_number < 25:
            first_round = UltimatumGameRound.objects.get(game_match_uuid=self.match_id, round_number=1)
            
            UltimatumGameRound.objects.create(
                game_match_uuid=self.match_id,
                round_number=current_round.round_number + 1,
                game_mode=first_round.game_mode,
                player_1_fingerprint=first_round.player_1_fingerprint,
                player_2_fingerprint=first_round.player_2_fingerprint,
                player_1_country=first_round.player_1_country,
                player_1_city=first_round.player_1_city,
                player_2_country=first_round.player_2_country,
                player_2_city=first_round.player_2_city,
            )

    @database_sync_to_async
    def get_game_state(self):
        rounds = list(UltimatumGameRound.objects.filter(
            game_match_uuid=self.match_id
        ).order_by('round_number'))
        
        if not rounds:
            return {"error": "No rounds found"}
        
        first_round = rounds[0]
        current_round = rounds[-1]
        
        # Calculate totals from completed rounds
        completed_rounds = [r for r in rounds if (
            r.proposer_offer is not None and r.responder_response is not None
        )]
        
        total_p1_score = sum(r.player_1_coins_made_in_round for r in completed_rounds)
        total_p2_score = sum(r.player_2_coins_made_in_round for r in completed_rounds)
        
        # Build history
        history = []
        for r in completed_rounds:
            history.append({
                "roundNumber": r.round_number,
                "proposerFingerprint": r.current_proposer_fingerprint,
                "responderFingerprint": r.current_responder_fingerprint,
                "offer": r.proposer_offer,
                "response": r.responder_response,
                "proposerEarned": (100 - r.proposer_offer) if r.responder_response == "accept" else 0,
                "responderEarned": r.proposer_offer if r.responder_response == "accept" else 0,
                "player1Earned": r.player_1_coins_made_in_round,
                "player2Earned": r.player_2_coins_made_in_round,
            })
        
        next_round = len(completed_rounds) + 1
        game_over = current_round.match_complete or next_round > 25
        waiting_for_opponent = (first_round.player_2_fingerprint is None and 
                              first_round.game_mode == "online")
        
        return {
            "currentRound": min(next_round, 25),
            "maxRounds": 25,
            "player1Score": total_p1_score,
            "player2Score": total_p2_score,
            "roundHistory": history,
            "waitingForOpponent": waiting_for_opponent,
            "gameOver": game_over,
            "gameMode": first_round.game_mode,
            "player1Fingerprint": first_round.player_1_fingerprint,
            "player2Fingerprint": first_round.player_2_fingerprint,
            "currentRoundState": {
                "roundNumber": current_round.round_number,
                "proposerFingerprint": current_round.current_proposer_fingerprint,
                "responderFingerprint": current_round.current_responder_fingerprint,
                "offerMade": current_round.proposer_offer is not None,
                "responseMade": current_round.responder_response is not None,
                "offer": current_round.proposer_offer,
                "response": current_round.responder_response,
            }
        }

    # Bot helpers
    async def make_bot_offer(self):
        offer = random.randint(20, 50)
        await self.process_offer("bot", offer)
        await self.channel_layer.group_send(self.room_group_name, {
            "type": "game_action",
            "player_fingerprint": "bot",
            "action": "make_offer",
            "offer": offer,
        })

    async def make_bot_response(self):
        # Simple bot strategy: accept if offer >= 30, otherwise reject
        current_round = await self.get_current_round()
        if current_round and current_round.proposer_offer is not None:
            response = "accept" if current_round.proposer_offer >= 30 else "reject"
            
            await self.process_response("bot", response)
            await self.channel_layer.group_send(self.room_group_name, {
                "type": "game_action",
                "player_fingerprint": "bot",
                "action": "respond_to_offer",
                "response": response,
            })
and this is ultimatum/game_logic.py:
from .models import UltimatumGameRound
from django.utils import timezone

def calculate_ultimatum_payoff(offer, response):

    if response == "accept":
        proposer_coins = 100 - offer  
        responder_coins = offer       
        total_coins = 100
    else:  # reject
        proposer_coins = 0
        responder_coins = 0
        total_coins = 0
    
    return proposer_coins, responder_coins, total_coins

def calculate_match_statistics(match_uuid, current_round_number):
    """Calculate acceptance rates and average offers for the match"""
    completed_rounds = UltimatumGameRound.objects.filter(
        game_match_uuid=match_uuid,
        round_number__lte=current_round_number,
        proposer_offer__isnull=False,
        responder_response__isnull=False
    ).order_by('round_number')
    
    if not completed_rounds.exists():
        return 0, 0, 0, 0
    
    total_rounds = completed_rounds.count()
    accepted_rounds = completed_rounds.filter(responder_response='accept').count()
    match_acceptance_rate = (accepted_rounds / total_rounds) * 100 if total_rounds > 0 else 0
    
    total_offers = sum(r.proposer_offer for r in completed_rounds)
    match_average_offer = total_offers / total_rounds if total_rounds > 0 else 0
    
    # Current round stats
    current_round = completed_rounds.filter(round_number=current_round_number).first()
    if current_round:
        round_acceptance = 100 if current_round.responder_response == 'accept' else 0
        round_offer = current_round.proposer_offer
    else:
        round_acceptance = 0
        round_offer = 0
    
    return round_acceptance, match_acceptance_rate, round_offer, match_average_offer

def update_game_stats(match_uuid, round_number):
    """Update game statistics after each completed round"""
    try:
        current_round = UltimatumGameRound.objects.get(
            game_match_uuid=match_uuid,
            round_number=round_number
        )
    except UltimatumGameRound.DoesNotExist:
        return
    
    # Check if round is complete
    if current_round.proposer_offer is None or current_round.responder_response is None:
        return    
    current_round.proposer_keeps = 100 - current_round.proposer_offer
    
    # Calculate round payoff
    proposer_coins, responder_coins, total_coins = calculate_ultimatum_payoff(
        current_round.proposer_offer,
        current_round.responder_response
    )
    
    # Assign coins to correct players based on roles
    if current_round.player_1_role == 'proposer':
        current_round.player_1_coins_made_in_round = proposer_coins
        current_round.player_2_coins_made_in_round = responder_coins
    else:
        current_round.player_1_coins_made_in_round = responder_coins
        current_round.player_2_coins_made_in_round = proposer_coins
    
    current_round.players_sum_coins_in_round = total_coins
    current_round.round_end = timezone.now().strftime('%Y-%m-%d %H:%M')
    
    # Calculate cumulative scores
    previous_rounds = UltimatumGameRound.objects.filter(
        game_match_uuid=match_uuid,
        round_number__lt=round_number
    )
    
    p1_cumulative = sum(r.player_1_coins_made_in_round for r in previous_rounds) + current_round.player_1_coins_made_in_round
    p2_cumulative = sum(r.player_2_coins_made_in_round for r in previous_rounds) + current_round.player_2_coins_made_in_round
    total_cumulative = p1_cumulative + p2_cumulative
    
    current_round.round_player_1_cumulative_score = p1_cumulative
    current_round.round_player_2_cumulative_score = p2_cumulative
    current_round.players_sum_coins_total = total_cumulative
    
    # Calculate statistics
    (round_acceptance, match_acceptance, 
     round_offer, match_offer) = calculate_match_statistics(match_uuid, round_number)
    
    current_round.round_acceptance_rate = round_acceptance
    current_round.match_acceptance_rate = match_acceptance
    current_round.round_average_offer = round_offer
    current_round.match_average_offer = match_offer
    
    # Check if game is complete
    if round_number >= 25:
        current_round.match_complete = True
        current_round.match_completed_at = timezone.now().strftime('%Y-%m-%d %H:%M')
        current_round.player_1_final_score = p1_cumulative
        current_round.player_2_final_score = p2_cumulative
        
        UltimatumGameRound.objects.filter(game_match_uuid=match_uuid).update(
            match_complete=True,
            match_completed_at=current_round.match_completed_at,
            player_1_final_score=p1_cumulative,
            player_2_final_score=p2_cumulative,
            match_acceptance_rate=match_acceptance,
            match_average_offer=match_offer
        )
    
    current_round.save()

def cleanup_incomplete_matches():
    """Clean up incomplete matches"""
    match_uuids = UltimatumGameRound.objects.values_list('game_match_uuid', flat=True).distinct()
    deleted_count = 0
    
    for match_uuid in match_uuids:
        if UltimatumGameRound.delete_incomplete_match(match_uuid):
            deleted_count += 1
    
    return deleted_count
and this is ultimatum/models.py:
from django.db import models
from django.utils import timezone
import uuid

class UltimatumGameRound(models.Model):
    GAME_MODES = [
        ('online', 'Online'),
        ('bot', 'Bot'),
    ]
    
    RESPONSE_CHOICES = [
        ('accept', 'Accept'),
        ('reject', 'Reject'),
    ]
    
    ROLE_CHOICES = [
        ('proposer', 'Proposer'),
        ('responder', 'Responder'),
    ]
    
    # Primary identifiers
    row_number = models.AutoField(primary_key=True)
    game_match_uuid = models.CharField(max_length=8, db_index=True)
    round_number = models.IntegerField()
    
    # Player information
    player_1_fingerprint = models.CharField(max_length=255)
    player_2_fingerprint = models.CharField(max_length=255, blank=True, null=True)
    player_1_country = models.CharField(max_length=100, default='Unknown')
    player_1_city = models.CharField(max_length=100, default='Unknown')
    player_2_country = models.CharField(max_length=100, blank=True, null=True, default='Unknown')
    player_2_city = models.CharField(max_length=100, blank=True, null=True, default='Unknown')
    
    # Game mode
    game_mode = models.CharField(max_length=10, choices=GAME_MODES, default='online')
    
    # Round roles (alternating each round)
    player_1_role = models.CharField(max_length=10, choices=ROLE_CHOICES, blank=True, null=True)
    player_2_role = models.CharField(max_length=10, choices=ROLE_CHOICES, blank=True, null=True)
    
    # Traditional Ultimatum Game actions
    proposer_offer = models.IntegerField(null=True, blank=True)  
    proposer_keeps = models.IntegerField(null=True, blank=True)  
    responder_response = models.CharField(max_length=10, choices=RESPONSE_CHOICES, null=True, blank=True)
    
    # Round results
    player_1_coins_made_in_round = models.IntegerField(default=0)
    player_2_coins_made_in_round = models.IntegerField(default=0)
    players_sum_coins_in_round = models.IntegerField(default=0)
    
    # Cumulative scores
    round_player_1_cumulative_score = models.IntegerField(default=0)
    round_player_2_cumulative_score = models.IntegerField(default=0)
    players_sum_coins_total = models.IntegerField(default=0)
    
    # Final scores (only populated on last round)
    player_1_final_score = models.IntegerField(default=0)
    player_2_final_score = models.IntegerField(default=0)
    
    round_acceptance_rate = models.FloatField(default=0)  # 0 or 100 for this round
    match_acceptance_rate = models.FloatField(default=0)  # Overall acceptance rate for match
    
    # Average offer amounts
    round_average_offer = models.FloatField(default=0)
    match_average_offer = models.FloatField(default=0)
    
    # Timestamps
    round_start = models.CharField(max_length=50, blank=True, null=True)
    round_end = models.CharField(max_length=50, blank=True, null=True)
    match_completed_at = models.CharField(max_length=50, blank=True, null=True)
    
    # Match status
    match_complete = models.BooleanField(default=False)
    
    class Meta:
        unique_together = ['game_match_uuid', 'round_number']
        ordering = ['game_match_uuid', 'round_number']
    
    def save(self, *args, **kwargs):
        if not self.round_start:
            self.round_start = timezone.now().strftime('%Y-%m-%d %H:%M')
        
        # Set roles for the round (alternating)
        if self.round_number and not self.player_1_role:
            if self.round_number % 2 == 1:  # Odd rounds: P1 proposes, P2 responds
                self.player_1_role = 'proposer'
                self.player_2_role = 'responder'
            else:  # Even rounds: P2 proposes, P1 responds
                self.player_1_role = 'responder'
                self.player_2_role = 'proposer'
        
        super().save(*args, **kwargs)
    
    def __str__(self):
        return f"Round {self.round_number} of Match {self.game_match_uuid}"

    @property
    def current_proposer_fingerprint(self):
        """Get the fingerprint of the current round's proposer"""
        if self.player_1_role == 'proposer':
            return self.player_1_fingerprint
        return self.player_2_fingerprint
    
    @property
    def current_responder_fingerprint(self):
        """Get the fingerprint of the current round's responder"""
        if self.player_1_role == 'responder':
            return self.player_1_fingerprint
        return self.player_2_fingerprint

    @classmethod
    def get_match_rounds(cls, match_uuid):
        """Get all rounds for a specific match"""
        return cls.objects.filter(game_match_uuid=match_uuid).order_by('round_number')
    
    @classmethod
    def get_completed_rounds_count(cls, match_uuid):
        """Get count of completed rounds for a match"""
        return cls.objects.filter(
            game_match_uuid=match_uuid,
            proposer_offer__isnull=False,
            responder_response__isnull=False
        ).count()
    
    @classmethod
    def delete_incomplete_match(cls, match_uuid):
        """Delete incomplete match if less than 25 rounds completed"""
        completed_count = cls.get_completed_rounds_count(match_uuid)
        if completed_count < 25:
            cls.objects.filter(game_match_uuid=match_uuid).delete()
            return True
        return False
and this is ultimatum/routing.py:
# ultimatum/routing.py

from django.urls import re_path
from . import consumers

websocket_urlpatterns = [
    # Match exactly 8-character match_id (alphanumeric)
    re_path(r'ws/ultimatum-game/(?P<match_id>\w{8})/$', 
            consumers.UltimatumGameConsumer.as_asgi()),
]
and this is ultimatum/test_ultimatum_game.py:
import asyncio
import json
import sys
import time
import random
from typing import Dict, List

try:
    import websockets
    import requests
    print("✅ Required packages available")
except ImportError as e:
    print(f"❌ Missing package: {e}")
    sys.exit(1)

class UltimatumGameTester:
    def __init__(self):
        self.base_url = "http://localhost:8001"
        self.ws_url = "ws://localhost:8001"
        self.match_results = {}
    
    def create_match(self, game_mode="online"):
        """Create a new match"""
        try:
            response = requests.post(
                f"{self.base_url}/api/ultimatum/create-match-ultimatum/",
                json={
                    "game_mode": game_mode, 
                    "player_fingerprint": f"player1_{int(time.time())}"
                },
                timeout=10
            )
            
            if response.status_code == 200:
                result = response.json()
                match_id = result.get("match_id")
                print(f"✅ Match created: {match_id} (mode: {game_mode})")
                return match_id, result
            else:
                print(f"❌ Failed to create match: {response.text}")
                return None, None
                
        except Exception as e:
            print(f"❌ Error creating match: {e}")
            return None, None
    
    def join_match(self, player_fingerprint):
        """Join existing match as second player"""
        try:
            response = requests.post(
                f"{self.base_url}/api/ultimatum/create-match-ultimatum/",
                json={
                    "game_mode": "online", 
                    "player_fingerprint": player_fingerprint
                },
                timeout=10
            )
            
            if response.status_code == 200:
                result = response.json()
                if result.get("status") == "joined_existing_match":
                    print(f"✅ Player joined match: {result.get('match_id')}")
                    return result.get('match_id'), result
            
            return None, None
                
        except Exception as e:
            print(f"❌ Error joining match: {e}")
            return None, None

    async def play_full_25_round_game(self, match_id, player1_fp, player2_fp):
        """Play a complete 25-round game and verify calculations"""
        print(f"\n🎮 STARTING 25-ROUND GAME: {match_id}")
        print("="*60)
        
        uri1 = f"{self.ws_url}/ws/ultimatum-game/{match_id}/"
        uri2 = f"{self.ws_url}/ws/ultimatum-game/{match_id}/"
        
        game_log = {
            'match_id': match_id,
            'rounds': [],
            'player1': {'total_score': 0, 'rounds_as_proposer': 0, 'rounds_as_responder': 0},
            'player2': {'total_score': 0, 'rounds_as_proposer': 0, 'rounds_as_responder': 0},
            'total_accepted': 0,
            'total_rejected': 0
        }
        
        try:
            async with websockets.connect(uri1) as ws1, websockets.connect(uri2) as ws2:
                print("✅ Both players connected via WebSocket")
                
                # Join game
                await ws1.send(json.dumps({
                    "action": "join",
                    "player_fingerprint": player1_fp
                }))
                
                await ws2.send(json.dumps({
                    "action": "join", 
                    "player_fingerprint": player2_fp
                }))
                
                # Get initial states
                initial1 = await ws1.recv()
                initial2 = await ws2.recv()
                
                print("✅ Game initialized, starting rounds...")
                
                # Play 25 rounds
                for round_num in range(1, 26):
                    print(f"\n🔄 ROUND {round_num}/25")
                    
                    # Determine roles (alternating)
                    if round_num % 2 == 1:  # Odd rounds: P1 proposes, P2 responds
                        proposer_ws, proposer_fp = ws1, player1_fp
                        responder_ws, responder_fp = ws2, player2_fp
                        proposer_name, responder_name = "Player1", "Player2"
                    else:  # Even rounds: P2 proposes, P1 responds
                        proposer_ws, proposer_fp = ws2, player2_fp
                        responder_ws, responder_fp = ws1, player1_fp
                        proposer_name, responder_name = "Player2", "Player1"
                    
                    # Generate realistic offer (20-50 range with some strategy)
                    if round_num <= 5:
                        offer = random.randint(35, 45)  # More generous early
                    elif round_num <= 15:
                        offer = random.randint(25, 40)  # Learning phase
                    else:
                        offer = random.randint(20, 35)  # More strategic later
                    
                    print(f"   💰 {proposer_name} (proposer) offering: {offer}")
                    
                    # Make offer
                    await proposer_ws.send(json.dumps({
                        "action": "make_offer",
                        "player_fingerprint": proposer_fp,
                        "offer": offer
                    }))
                    
                    # Wait for offer confirmation
                    await asyncio.sleep(0.2)
                    
                    # Responder strategy: accept if >= 25, otherwise 70% chance to accept
                    if offer >= 25:
                        response = "accept"
                    else:
                        response = "accept" if random.random() > 0.3 else "reject"
                    
                    print(f"   🤔 {responder_name} (responder) responding: {response}")
                    
                    # Make response
                    await responder_ws.send(json.dumps({
                        "action": "respond_to_offer",
                        "player_fingerprint": responder_fp,
                        "response": response
                    }))
                    
                    # Wait for round completion
                    await asyncio.sleep(0.5)
                    
                    # Calculate expected scores for this round
                    if response == "accept":
                        proposer_earned = 100 - offer
                        responder_earned = offer
                        game_log['total_accepted'] += 1
                    else:
                        proposer_earned = 0
                        responder_earned = 0
                        game_log['total_rejected'] += 1
                    
                    # Update tracking
                    if round_num % 2 == 1:  # P1 was proposer
                        game_log['player1']['total_score'] += proposer_earned
                        game_log['player2']['total_score'] += responder_earned
                        game_log['player1']['rounds_as_proposer'] += 1
                        game_log['player2']['rounds_as_responder'] += 1
                    else:  # P2 was proposer
                        game_log['player2']['total_score'] += proposer_earned
                        game_log['player1']['total_score'] += responder_earned
                        game_log['player2']['rounds_as_proposer'] += 1
                        game_log['player1']['rounds_as_responder'] += 1
                    
                    # Log round details
                    round_data = {
                        'round': round_num,
                        'proposer': proposer_name,
                        'responder': responder_name,
                        'offer': offer,
                        'response': response,
                        'proposer_earned': proposer_earned,
                        'responder_earned': responder_earned,
                        'p1_total': game_log['player1']['total_score'],
                        'p2_total': game_log['player2']['total_score']
                    }
                    game_log['rounds'].append(round_data)
                    
                    print(f"   📊 Scores: P1={game_log['player1']['total_score']}, P2={game_log['player2']['total_score']}")
                    
                    # Brief pause between rounds
                    await asyncio.sleep(0.1)
                
                print(f"\n🏁 GAME COMPLETED!")
                
                # Wait a moment for final updates
                await asyncio.sleep(2)
                
                # Get final game state to verify calculations
                await self.verify_final_results(ws1, game_log)
                
                return game_log
                
        except websockets.exceptions.ConnectionClosed as e:
            print(f"❌ WebSocket connection closed during game: {e}")
            return None
        except Exception as e:
            print(f"❌ Error during game: {e}")
            return None
    
    async def verify_final_results(self, ws, expected_log):
        """Verify the final game state matches our calculations"""
        print(f"\n🔍 VERIFYING FINAL RESULTS")
        print("-" * 40)
        
        try:
            # Try to get final game state (this might need adjustment based on your WebSocket implementation)
            # For now, let's use the match stats endpoint
            match_id = expected_log['match_id']
            
            await asyncio.sleep(1)  # Give server time to process
            
            # Check via HTTP endpoint
            response = requests.get(f"{self.base_url}/ultimatum_game/match-stats/{match_id}/")
            
            if response.status_code == 200:
                stats = response.json()
                
                print("📊 SERVER STATS:")
                print(f"   Player 1 Final Score: {stats.get('player_1_final_score', 'N/A')}")
                print(f"   Player 2 Final Score: {stats.get('player_2_final_score', 'N/A')}")
                print(f"   Total Rounds: {stats.get('total_rounds', 'N/A')}")
                print(f"   Acceptance Rate: {stats.get('overall_acceptance_rate', 'N/A')}%")
                print(f"   Average Offer: {stats.get('overall_average_offer', 'N/A')}")
                
                print("\n📊 EXPECTED STATS:")
                print(f"   Player 1 Final Score: {expected_log['player1']['total_score']}")
                print(f"   Player 2 Final Score: {expected_log['player2']['total_score']}")
                print(f"   Total Rounds: 25")
                expected_acceptance = (expected_log['total_accepted'] / 25) * 100
                print(f"   Acceptance Rate: {expected_acceptance:.1f}%")
                
                # Verify calculations
                p1_match = stats.get('player_1_final_score') == expected_log['player1']['total_score']
                p2_match = stats.get('player_2_final_score') == expected_log['player2']['total_score']
                rounds_match = stats.get('total_rounds') == 25
                
                print(f"\n✅ VERIFICATION RESULTS:")
                print(f"   Player 1 Score Match: {'✅' if p1_match else '❌'}")
                print(f"   Player 2 Score Match: {'✅' if p2_match else '❌'}")
                print(f"   Rounds Complete: {'✅' if rounds_match else '❌'}")
                
                if p1_match and p2_match and rounds_match:
                    print(f"   🎉 ALL CALCULATIONS CORRECT!")
                else:
                    print(f"   ⚠️  CALCULATION MISMATCHES DETECTED")
                
            else:
                print(f"❌ Could not get server stats: {response.status_code}")
                
        except Exception as e:
            print(f"❌ Error verifying results: {e}")
    
    def print_game_summary(self, game_log):
        """Print detailed game summary"""
        if not game_log:
            return
            
        print(f"\n📋 GAME SUMMARY - Match {game_log['match_id']}")
        print("="*60)
        
        print(f"🎯 FINAL SCORES:")
        print(f"   Player 1: {game_log['player1']['total_score']} coins")
        print(f"   Player 2: {game_log['player2']['total_score']} coins")
        
        print(f"\n📊 GAME STATISTICS:")
        print(f"   Total Rounds: 25")
        print(f"   Accepted Offers: {game_log['total_accepted']}")
        print(f"   Rejected Offers: {game_log['total_rejected']}")
        print(f"   Acceptance Rate: {(game_log['total_accepted']/25)*100:.1f}%")
        
        # Calculate average offers
        total_offers = sum(round_data['offer'] for round_data in game_log['rounds'])
        avg_offer = total_offers / 25
        print(f"   Average Offer: {avg_offer:.1f}")
        
        print(f"\n🎭 ROLE DISTRIBUTION:")
        print(f"   Player 1 as Proposer: {game_log['player1']['rounds_as_proposer']} rounds")
        print(f"   Player 1 as Responder: {game_log['player1']['rounds_as_responder']} rounds")
        print(f"   Player 2 as Proposer: {game_log['player2']['rounds_as_proposer']} rounds")
        print(f"   Player 2 as Responder: {game_log['player2']['rounds_as_responder']} rounds")
        
        # Show last 5 rounds for verification
        print(f"\n🔍 LAST 5 ROUNDS DETAIL:")
        for round_data in game_log['rounds'][-5:]:
            print(f"   R{round_data['round']:2d}: {round_data['proposer']} offered {round_data['offer']:2d} → "
                  f"{round_data['response']:6s} → P1:{round_data['p1_total']:3d}, P2:{round_data['p2_total']:3d}")

    async def test_bot_game_25_rounds(self):
        """Test a full 25-round game against bot"""
        print(f"\n🤖 TESTING 25-ROUND BOT GAME")
        print("="*50)
        
        # Create bot match
        match_id, _ = self.create_match("bot")
        if not match_id:
            return None
            
        uri = f"{self.ws_url}/ws/ultimatum-game/{match_id}/"
        player_fp = f"bot_player_{int(time.time())}"
        
        bot_log = {
            'match_id': match_id,
            'rounds': [],
            'player_score': 0,
            'bot_score': 0,
            'total_accepted': 0,
            'total_rejected': 0
        }
        
        try:
            async with websockets.connect(uri) as ws:
                print("✅ Connected to bot game")
                
                # Join
                await ws.send(json.dumps({
                    "action": "join",
                    "player_fingerprint": player_fp
                }))
                
                await ws.recv()  # Initial state
                
                # Play 25 rounds against bot
                for round_num in range(1, 26):
                    print(f"🔄 Bot Round {round_num}/25", end=" ")
                    
                    if round_num % 2 == 1:  # Player proposes
                        offer = random.randint(25, 45)
                        print(f"- Player offers {offer}", end="")
                        
                        await ws.send(json.dumps({
                            "action": "make_offer",
                            "player_fingerprint": player_fp,
                            "offer": offer
                        }))
                        
                        # Bot responds (based on your bot logic: accept if >= 30)
                        response = "accept" if offer >= 30 else "reject"
                        
                        if response == "accept":
                            bot_log['player_score'] += (100 - offer)
                            bot_log['bot_score'] += offer
                            bot_log['total_accepted'] += 1
                        else:
                            bot_log['total_rejected'] += 1
                        
                        print(f" → Bot {response}s")
                        
                    else:  # Bot proposes (bot offers 20-50, per your code)
                        # Wait for bot offer
                        await asyncio.sleep(0.5)
                        
                        # Player responds (accept if >= 25)
                        bot_offer = random.randint(20, 50)  # Simulate bot offer
                        response = "accept" if bot_offer >= 25 else "reject"
                        
                        print(f"- Bot offers ~{bot_offer}, Player {response}s")
                        
                        await ws.send(json.dumps({
                            "action": "respond_to_offer",
                            "player_fingerprint": player_fp,
                            "response": response
                        }))
                        
                        if response == "accept":
                            bot_log['bot_score'] += (100 - bot_offer)
                            bot_log['player_score'] += bot_offer
                            bot_log['total_accepted'] += 1
                        else:
                            bot_log['total_rejected'] += 1
                    
                    await asyncio.sleep(0.3)
                
                print(f"\n✅ Bot game completed!")
                print(f"   Player Score: {bot_log['player_score']}")
                print(f"   Bot Score: {bot_log['bot_score']}")
                print(f"   Acceptance Rate: {(bot_log['total_accepted']/25)*100:.1f}%")
                
                return bot_log
                
        except Exception as e:
            print(f"❌ Bot game error: {e}")
            return None

async def main():
    print("🎲 ULTIMATUM GAME - 25 ROUND CALCULATION TEST")
    print(f"🕐 Started: {time.strftime('%Y-%m-%d %H:%M:%S UTC', time.gmtime())}")
    print(f"👤 User: sobouriic")
    print("="*70)
    
    tester = UltimatumGameTester()
    
    # Test 1: Full 25-round online game
    print("\n🎮 TEST 1: 25-ROUND ONLINE GAME")
    match_id, _ = tester.create_match("online")
    
    if match_id:
        # Second player joins
        player2_fp = f"player2_{int(time.time())}"
        tester.join_match(player2_fp)
        
        # Play full game
        game_log = await tester.play_full_25_round_game(
            match_id, 
            f"player1_{int(time.time())}", 
            player2_fp
        )
        
        if game_log:
            tester.print_game_summary(game_log)
    
    # Test 2: Bot game
    print("\n🤖 TEST 2: 25-ROUND BOT GAME")
    bot_log = await tester.test_bot_game_25_rounds()
    
    print("\n🏁 ALL TESTS COMPLETED")
    print("="*70)
    print("✅ WebSocket connections tested for full 25-round games")
    print("✅ Game calculations and scoring verified")
    print("✅ Both online and bot modes tested")

if __name__ == "__main__":
    asyncio.run(main())
and this is urls.py:
from django.urls import path
from . import views

app_name = 'ultimatum_game'

urlpatterns = [
    path('create-match-ultimatum/', views.create_match, name='create_match-ultimatum'),
    path('game-page/<str:match_id>/', views.game_page, name='game_page'),
    
    # Match data endpoints
    path('match-history/<str:match_id>/', views.match_history, name='match_history'),
    path('match-stats/<str:match_id>/', views.match_stats, name='match_stats'),
    path('active-matches/', views.active_matches, name='active_matches'),
    
    # Admin endpoints
    path('cleanup-matches/', views.cleanup_matches, name='cleanup_matches'),
]
and this is ultimatum/views.py:
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from django.shortcuts import render
import json
import uuid
from .models import UltimatumGameRound

@csrf_exempt
def create_match(request):
    """Create or join an Ultimatum Game match"""
    if request.method == 'POST':
        try:
            data = json.loads(request.body)
        except json.JSONDecodeError:
            return JsonResponse({'status': 'error', 'message': 'Invalid JSON'}, status=400)
        
        game_mode = data.get('game_mode', 'online')
        player_fingerprint = data.get('player_fingerprint')

        if not player_fingerprint:
            return JsonResponse({
                'status': 'error', 
                'message': 'Player fingerprint is required'
            }, status=400)

        ip_address = request.META.get('REMOTE_ADDR', '127.0.0.1')
        
        try:
            if game_mode == 'online':
                # Try to find an existing match waiting for a second player
                existing_round = UltimatumGameRound.objects.filter(
                    game_mode='online',
                    player_2_fingerprint__isnull=True,
                    match_complete=False,
                    round_number=1
                ).first()
                
                if existing_round and existing_round.player_1_fingerprint == player_fingerprint:
                    return JsonResponse({
                        "status": "error",
                        "message": "You are already registered in this match."
                    }, status=400)
                
                if existing_round:
                    # Join existing match
                    existing_round.player_2_fingerprint = player_fingerprint
                    existing_round.player_2_country = 'Unknown'
                    existing_round.player_2_city = 'Unknown'
                    existing_round.save()
                    
                    status_message = 'joined_existing_match'
                    match_id = existing_round.game_match_uuid
                    print(f"Player {player_fingerprint} joined existing match {match_id}")
                    
                    return JsonResponse({
                        'status': status_message,
                        'match_id': match_id,
                        'game_mode': existing_round.game_mode,
                        'player_1_fingerprint': existing_round.player_1_fingerprint,
                        'player_2_fingerprint': existing_round.player_2_fingerprint,
                    })
                else:
                    # Create new match
                    match_id = str(uuid.uuid4())[:8]
                    new_round = UltimatumGameRound.objects.create(
                        game_match_uuid=match_id,
                        round_number=1,
                        game_mode=game_mode,
                        player_1_fingerprint=player_fingerprint,
                        player_1_country='Unknown',
                        player_1_city='Unknown'
                    )
                    status_message = 'created_new_match'
                    print(f"Player {player_fingerprint} created new match {match_id}")
                    
                    return JsonResponse({
                        'status': status_message,
                        'match_id': match_id,
                        'game_mode': new_round.game_mode,
                        'player_1_fingerprint': new_round.player_1_fingerprint,
                        'player_2_fingerprint': new_round.player_2_fingerprint,
                    })
                    
            elif game_mode == 'bot':
                # Create bot match
                match_id = str(uuid.uuid4())[:8]
                new_round = UltimatumGameRound.objects.create(
                    game_match_uuid=match_id,
                    round_number=1,
                    game_mode=game_mode,
                    player_1_fingerprint=player_fingerprint,
                    player_1_country='Unknown',
                    player_1_city='Unknown',
                    player_2_fingerprint='bot',
                    player_2_country='Bot',
                    player_2_city='Bot'
                )
                status_message = 'created_bot_match'
                print(f"Player {player_fingerprint} created bot match {match_id}")
                
                return JsonResponse({
                    'status': status_message,
                    'match_id': match_id,
                    'game_mode': new_round.game_mode,
                    'player_1_fingerprint': new_round.player_1_fingerprint,
                    'player_2_fingerprint': new_round.player_2_fingerprint,
                })
            else:
                return JsonResponse({
                    'status': 'error', 
                    'message': 'Invalid game mode'
                }, status=400)
                
        except Exception as e:
            return JsonResponse({
                'status': 'error', 
                'message': f'Database error: {str(e)}'
            }, status=500)
    
    return JsonResponse({
        'status': 'error', 
        'message': 'Invalid request method'
    }, status=405)

def game_page(request, match_id):
    """Render the game page for a specific match"""
    try:
        # Check if match exists
        match_exists = UltimatumGameRound.objects.filter(
            game_match_uuid=match_id
        ).exists()
        
        if not match_exists:
            return render(request, 'ultimatum_game/error.html', {
                'error_message': 'Match not found'
            })
        
        # Get match info
        first_round = UltimatumGameRound.objects.filter(
            game_match_uuid=match_id,
            round_number=1
        ).first()
        
        context = {
            'match_id': match_id,
            'game_mode': first_round.game_mode if first_round else 'online',
            'websocket_url': f'ws://localhost:8000/ws/ultimatum-game/{match_id}/',
        }
        
        return render(request, 'ultimatum_game/game.html', context)
        
    except Exception as e:
        return render(request, 'ultimatum_game/error.html', {
            'error_message': f'Error loading game: {str(e)}'
        })

def match_history(request, match_id):
    """Get the history of a specific match"""
    try:
        rounds = UltimatumGameRound.objects.filter(
            game_match_uuid=match_id,
            proposer_offer__isnull=False,
            responder_response__isnull=False
        ).order_by('round_number')
        
        if not rounds.exists():
            return JsonResponse({
                'status': 'error',
                'message': 'No completed rounds found for this match'
            }, status=404)
        
        history = []
        for round_obj in rounds:
            history.append({
                'round_number': round_obj.round_number,
                'proposer_fingerprint': round_obj.current_proposer_fingerprint,
                'responder_fingerprint': round_obj.current_responder_fingerprint,
                'proposer_role': f"Player {1 if round_obj.player_1_role == 'proposer' else 2}",
                'responder_role': f"Player {1 if round_obj.player_1_role == 'responder' else 2}",
                'offer': round_obj.proposer_offer,
                'response': round_obj.responder_response,
                'proposer_earned': (100 - round_obj.proposer_offer) if round_obj.responder_response == 'accept' else 0,
                'responder_earned': round_obj.proposer_offer if round_obj.responder_response == 'accept' else 0,
                'player_1_earned': round_obj.player_1_coins_made_in_round,
                'player_2_earned': round_obj.player_2_coins_made_in_round,
                'player_1_cumulative': round_obj.round_player_1_cumulative_score,
                'player_2_cumulative': round_obj.round_player_2_cumulative_score,
                'round_start': round_obj.round_start,
                'round_end': round_obj.round_end,
            })
        
        # Get final match statistics
        last_round = rounds.last()
        
        return JsonResponse({
            'status': 'success',
            'match_id': match_id,
            'game_mode': last_round.game_mode,
            'total_rounds': rounds.count(),
            'match_complete': last_round.match_complete,
            'player_1_final_score': last_round.player_1_final_score,
            'player_2_final_score': last_round.player_2_final_score,
            'match_acceptance_rate': last_round.match_acceptance_rate,
            'match_average_offer': last_round.match_average_offer,
            'history': history
        })
        
    except Exception as e:
        return JsonResponse({
            'status': 'error',
            'message': f'Error retrieving match history: {str(e)}'
        }, status=500)

def match_stats(request, match_id):
    """Get statistics for a specific match"""
    try:
        rounds = UltimatumGameRound.objects.filter(
            game_match_uuid=match_id,
            proposer_offer__isnull=False,
            responder_response__isnull=False
        ).order_by('round_number')
        
        if not rounds.exists():
            return JsonResponse({
                'status': 'error',
                'message': 'No completed rounds found for this match'
            }, status=404)
        
        last_round = rounds.last()
        
        # Calculate additional statistics
        total_rounds = rounds.count()
        accepted_rounds = rounds.filter(responder_response='accept').count()
        rejected_rounds = rounds.filter(responder_response='reject').count()
        
        offers = [r.proposer_offer for r in rounds]
        min_offer = min(offers) if offers else 0
        max_offer = max(offers) if offers else 0
        
        # Player-specific stats
        p1_as_proposer = rounds.filter(player_1_role='proposer')
        p2_as_proposer = rounds.filter(player_2_role='proposer')
        
        p1_proposer_acceptance_rate = 0
        p2_proposer_acceptance_rate = 0
        p1_average_offer = 0
        p2_average_offer = 0
        
        if p1_as_proposer.exists():
            p1_accepted = p1_as_proposer.filter(responder_response='accept').count()
            p1_proposer_acceptance_rate = (p1_accepted / p1_as_proposer.count()) * 100
            p1_average_offer = sum(r.proposer_offer for r in p1_as_proposer) / p1_as_proposer.count()
        
        if p2_as_proposer.exists():
            p2_accepted = p2_as_proposer.filter(responder_response='accept').count()
            p2_proposer_acceptance_rate = (p2_accepted / p2_as_proposer.count()) * 100
            p2_average_offer = sum(r.proposer_offer for r in p2_as_proposer) / p2_as_proposer.count()
        
        return JsonResponse({
            'status': 'success',
            'match_id': match_id,
            'game_mode': last_round.game_mode,
            'match_complete': last_round.match_complete,
            'total_rounds': total_rounds,
            'completed_rounds': total_rounds,
            'accepted_rounds': accepted_rounds,
            'rejected_rounds': rejected_rounds,
            'overall_acceptance_rate': last_round.match_acceptance_rate,
            'overall_average_offer': last_round.match_average_offer,
            'min_offer': min_offer,
            'max_offer': max_offer,
            'player_1_final_score': last_round.player_1_final_score,
            'player_2_final_score': last_round.player_2_final_score,
            'player_1_proposer_acceptance_rate': p1_proposer_acceptance_rate,
            'player_2_proposer_acceptance_rate': p2_proposer_acceptance_rate,
            'player_1_average_offer': p1_average_offer,
            'player_2_average_offer': p2_average_offer,
            'match_completed_at': last_round.match_completed_at,
        })
        
    except Exception as e:
        return JsonResponse({
            'status': 'error',
            'message': f'Error retrieving match statistics: {str(e)}'
        }, status=500)

def active_matches(request):
    """Get list of active (incomplete) matches"""
    try:
        active_matches = UltimatumGameRound.objects.filter(
            match_complete=False,
            round_number=1
        ).order_by('-row_number')
        
        matches_data = []
        for match in active_matches:
            completed_rounds = UltimatumGameRound.get_completed_rounds_count(match.game_match_uuid)
            
            matches_data.append({
                'match_id': match.game_match_uuid,
                'game_mode': match.game_mode,
                'player_1_fingerprint': match.player_1_fingerprint,
                'player_2_fingerprint': match.player_2_fingerprint,
                'waiting_for_player_2': match.player_2_fingerprint is None,
                'completed_rounds': completed_rounds,
                'created_at': match.round_start,
            })
        
        return JsonResponse({
            'status': 'success',
            'active_matches': matches_data,
            'total_active': len(matches_data)
        })
        
    except Exception as e:
        return JsonResponse({
            'status': 'error',
            'message': f'Error retrieving active matches: {str(e)}'
        }, status=500)

def home(request):
    """Home page for the Ultimatum Game"""
    return render(request, 'ultimatum_game/home.html')

def rules(request):
    """Rules page explaining the Ultimatum Game"""
    return render(request, 'ultimatum_game/rules.html')

@csrf_exempt
def cleanup_matches(request):
    """Admin endpoint to cleanup incomplete matches"""
    if request.method == 'POST':
        try:
            from .game_logic import cleanup_incomplete_matches
            deleted_count = cleanup_incomplete_matches()
            
            return JsonResponse({
                'status': 'success',
                'message': f'Cleaned up {deleted_count} incomplete matches'
            })
            
        except Exception as e:
            return JsonResponse({
                'status': 'error',
                'message': f'Error during cleanup: {str(e)}'
            }, status=500)
    
    return JsonResponse({
        'status': 'error',
        'message': 'Invalid request method'
    }, status=405) 
and now this is the front end of ultimatum :  

this is GamePage.jsx:

import { useState, useEffect, useCallback } from "react"
import { Clock, DollarSign, CheckCircle, XCircle, Wifi, WifiOff, Loader2 } from "lucide-react"
import { useNavigate, useSearchParams } from "react-router-dom"

import PayoffsTable from "./PayoffsTable"
import { useWebSocket } from "../hooks/useWebSocket"
import { gameApi, generatePlayerFingerprint } from "../services/gameApi"
import "./GamePage.css"

const MAX_ROUNDS = 25
const TOTAL_MONEY = 100

export default function GamePage() {
  const navigate = useNavigate()
  const [searchParams] = useSearchParams()
  const gameMode = searchParams.get("mode") || "online"

  // Player and match state
  const [playerFingerprint] = useState(() => generatePlayerFingerprint())
  const [matchId, setMatchId] = useState(null)
  const [isInitializing, setIsInitializing] = useState(true)

  // Game state
  const [inputOffer, setInputOffer] = useState("")
  const [timeLeft, setTimeLeft] = useState(30)
  const [currentPhase, setCurrentPhase] = useState("waiting") // waiting, proposing, responding, result

  // WebSocket connection
  const { gameState, connectionStatus, error, sendMessage } = useWebSocket(matchId, playerFingerprint)

  // Initialize match
  useEffect(() => {
    const initializeMatch = async () => {
      try {
        console.log("🚀 Initializing match with mode:", gameMode)
        const matchData = await gameApi.createMatch(gameMode, playerFingerprint)
        setMatchId(matchData.match_id)
        console.log("✅ Match initialized:", matchData.match_id)
      } catch (error) {
        console.error("❌ Failed to initialize match:", error)
      } finally {
        setIsInitializing(false)
      }
    }

    initializeMatch()
  }, [gameMode, playerFingerprint])

  // Update game phase based on game state
  useEffect(() => {
    if (!gameState) return

    console.log("🎮 Processing game state update:", gameState)

    if (gameState.gameOver) {
      setCurrentPhase("result")
      return
    }

    if (gameState.waitingForOpponent) {
      setCurrentPhase("waiting")
      return
    }

    const currentRound = gameState.currentRoundState
    if (!currentRound) return

    const isMyTurnToPropose = currentRound.proposerFingerprint === playerFingerprint
    const isMyTurnToRespond = currentRound.responderFingerprint === playerFingerprint

    console.log("🎯 Turn analysis:", {
      isMyTurnToPropose,
      isMyTurnToRespond,
      proposerFingerprint: currentRound.proposerFingerprint,
      responderFingerprint: currentRound.responderFingerprint,
      myFingerprint: playerFingerprint,
      offerMade: currentRound.offerMade,
      responseMade: currentRound.responseMade,
    })

    if (isMyTurnToPropose && !currentRound.offerMade) {
      setCurrentPhase("proposing")
      setTimeLeft(30)
    } else if (isMyTurnToRespond && currentRound.offerMade && !currentRound.responseMade) {
      setCurrentPhase("responding")
      setTimeLeft(30)
    } else {
      setCurrentPhase("waiting")
      setTimeLeft(15)
    }
  }, [gameState, playerFingerprint])

  // Timer countdown
  useEffect(() => {
    if (timeLeft <= 0 || currentPhase === "waiting" || currentPhase === "result") return

    const timer = setTimeout(() => {
      setTimeLeft((prev) => prev - 1)
    }, 1000)

    return () => clearTimeout(timer)
  }, [timeLeft, currentPhase])

  // Submit offer
  const submitOffer = useCallback(() => {
    const offer = Math.max(0, Math.min(+inputOffer || 0, TOTAL_MONEY))
    console.log("💰 Submitting offer:", offer)

    const success = sendMessage({
      action: "make_offer",
      player_fingerprint: playerFingerprint,
      offer: offer,
    })

    if (success) {
      setInputOffer("")
      setCurrentPhase("waiting")
    }
  }, [inputOffer, sendMessage, playerFingerprint])

  // Respond to offer
  const respondToOffer = useCallback(
    (accept) => {
      const response = accept ? "accept" : "reject"
      console.log("🤔 Responding to offer:", response)

      const success = sendMessage({
        action: "respond_to_offer",
        player_fingerprint: playerFingerprint,
        response: response,
      })

      if (success) {
        setCurrentPhase("waiting")
      }
    },
    [sendMessage, playerFingerprint],
  )

  // Loading state
  if (isInitializing || !matchId) {
    return (
      <div className="game-page">
        <div className="game-container">
          <div className="loading-section">
            <Loader2 className="loading-spinner" />
            <p>Initializing game...</p>
          </div>
        </div>
      </div>
    )
  }

  // Connection error state
  if (error) {
    return (
      <div className="game-page">
        <div className="game-container">
          <div className="error-section">
            <XCircle className="error-icon" />
            <h2>Connection Error</h2>
            <p>{error}</p>
            <button onClick={() => navigate("/ultimatum")} className="menu-button">
              Back to Menu
            </button>
          </div>
        </div>
      </div>
    )
  }

  // Game over state
  if (currentPhase === "result" && gameState?.gameOver) {
    return (
      <div className="game-over-page">
        <div className="game-over-container">
          <div className="game-over-header">
            <h1 className="game-over-title">Game Complete!</h1>
            <p>All {MAX_ROUNDS} rounds finished</p>
          </div>

          <div className="final-scores">
            <div className="score-card">
              <h3>Final Scores</h3>
              <div className="scores">
                <div className="score-item">
                  <span>Player 1:</span>
                  <span>${gameState.player1Score}</span>
                </div>
                <div className="score-item">
                  <span>Player 2:</span>
                  <span>${gameState.player2Score}</span>
                </div>
              </div>
            </div>
          </div>

          <div className="action-buttons">
            <button onClick={() => navigate("/ultimatum")} className="menu-button">
              Back to Menu
            </button>
          </div>

          <PayoffsTable history={gameState.roundHistory || []} />
        </div>
      </div>
    )
  }

  // Main game interface
  return (
    <div className="game-page">
      <div className="game-container">
        {/* Connection status */}
        <div className="connection-status">
          {connectionStatus === "connected" ? (
            <>
              <Wifi className="connection-icon connected" /> Connected
            </>
          ) : connectionStatus === "connecting" ? (
            <>
              <Loader2 className="connection-icon connecting" /> Connecting
            </>
          ) : (
            <>
              <WifiOff className="connection-icon disconnected" /> Disconnected
            </>
          )}
        </div>

        {/* Game header */}
        <div className="game-header">
          <h1 className="game-title">Ultimatum Game</h1>
          <p className="game-subtitle">
            Round {gameState?.currentRound || 1} of {MAX_ROUNDS}
          </p>
          <p className="match-id">Match ID: {matchId}</p>
        </div>

        {/* Main game card */}
        <div className="game-board">
          <div className="game-card">
            <div className="game-card-header">
              <div className="timer">
                <Clock className="timer-icon" />
                <span>{timeLeft}s</span>
              </div>
              <h2 className="phase-title">
                {currentPhase === "proposing" && "MAKE YOUR OFFER"}
                {currentPhase === "responding" && "RESPOND TO OFFER"}
                {currentPhase === "waiting" && "WAITING..."}
              </h2>
            </div>

            <div className="game-card-content">
              <div className="money-display">
                <div className="money-content">
                  <DollarSign className="money-icon" />
                  <span>{TOTAL_MONEY}</span>
                </div>
              </div>

              {/* Waiting for opponent */}
              {gameState?.waitingForOpponent && (
                <div className="waiting-section">
                  <div className="waiting-animation">
                    <Loader2 className="waiting-spinner" />
                    <p className="waiting-text">Waiting for opponent to join...</p>
                  </div>
                </div>
              )}

              {/* Proposing phase */}
              {currentPhase === "proposing" && (
                <>
                  <p className="offer-label">How much will you offer your opponent?</p>
                  <div className="offer-input-container">
                    <input
                      type="number"
                      value={inputOffer}
                      onChange={(e) => setInputOffer(e.target.value)}
                      min="0"
                      max={TOTAL_MONEY}
                      placeholder="0"
                      className="offer-input"
                    />
                    <div className="dollar-sign">$</div>
                  </div>
                  <button
                    onClick={submitOffer}
                    disabled={!inputOffer || +inputOffer < 0 || +inputOffer > TOTAL_MONEY}
                    className="submit-button"
                  >
                    SUBMIT OFFER
                  </button>
                </>
              )}

              {/* Responding phase */}
              {currentPhase === "responding" && gameState?.currentRoundState && (
                <div className="responding-section">
                  <div className="offer-display">
                    <p className="offer-label">Opponent offers you:</p>
                    <p className="offer-amount-large">${gameState.currentRoundState.offer}</p>
                  </div>

                  <div className="decision-info">
                    <p className="keep-amount">If you accept: You get ${gameState.currentRoundState.offer}</p>
                    <p className="keep-amount">If you reject: You get $0</p>
                  </div>

                  <div className="response-buttons">
                    <button onClick={() => respondToOffer(true)} className="accept-button">
                      <CheckCircle className="button-icon" />
                      ACCEPT
                    </button>
                    <button onClick={() => respondToOffer(false)} className="reject-button">
                      <XCircle className="button-icon" />
                      REJECT
                    </button>
                  </div>
                </div>
              )}

              {/* Waiting phase */}
              {currentPhase === "waiting" && !gameState?.waitingForOpponent && (
                <div className="waiting-section">
                  <div className="waiting-animation">
                    <Loader2 className="waiting-spinner" />
                    <p className="waiting-text">
                      {gameState?.currentRoundState?.offerMade && !gameState?.currentRoundState?.responseMade
                        ? "Waiting for opponent's response..."
                        : "Waiting for opponent's offer..."}
                    </p>
                  </div>
                </div>
              )}
            </div>
          </div>
        </div>

        {/* Scores */}
        {gameState && (
          <div className="scores-section">
            <div className="score-item">
              <span>Your Score:</span>
              <span>
                ${gameState.player1Fingerprint === playerFingerprint ? gameState.player1Score : gameState.player2Score}
              </span>
            </div>
            <div className="score-item">
              <span>Opponent Score:</span>
              <span>
                ${gameState.player1Fingerprint === playerFingerprint ? gameState.player2Score : gameState.player1Score}
              </span>
            </div>
          </div>
        )}

        {/* Payoffs table */}
        <div className="payoffs-area">
          <PayoffsTable history={gameState?.roundHistory || []} />
        </div>
      </div>
    </div>
  )
}
and this is HomePage.jsx:
"use client"

import { Users, Bot, Coins } from "lucide-react"
import { useNavigate } from "react-router-dom"
import "./HomePage.css"

export default function HomePage() {
  const navigate = useNavigate()

  const handleStartGame = (mode) => {
    if (mode === "online") {
      navigate("/ultimatum/matchmaking")
    } else {
      navigate(`/ultimatum/game?mode=${mode}`)
    }
  }

  return (
    <div className="homepage">
      <div className="homepage-container">
        <div className="homepage-header">
          <h1 className="homepage-title">Ultimatum</h1>
          <p className="homepage-subtitle">
            You and a player are dividing a stack of coins. If the other player rejects your proposal, you both get
            nothing. How much will you offer?
          </p>
        </div>

        {/* Game Description Card */}
        <div className="how-to-play-card">
          <div className="how-to-play-header">
            <Coins className="how-to-play-icon" />
            <h2 className="how-to-play-title">How to Play</h2>
          </div>
          <div className="how-to-play-steps">
            <div className="step">
              <div className="step-number">
                <span>1</span>
              </div>
              <h3 className="step-title">Make an Offer</h3>
              <p className="step-description">Decide how much of the $100 to offer your opponent</p>
            </div>
            <div className="step">
              <div className="step-number">
                <span>2</span>
              </div>
              <h3 className="step-title">Wait for Decision</h3>
              <p className="step-description">Your opponent will accept or reject your offer</p>
            </div>
            <div className="step">
              <div className="step-number">
                <span>3</span>
              </div>
              <h3 className="step-title">Get Results</h3>
              <p className="step-description">If accepted, you both get money. If rejected, nobody gets anything</p>
            </div>
          </div>
        </div>

        {/* Game Mode Selection */}
        <div className="game-modes">
          <div className="game-mode-card">
            <div className="game-mode-icon-container">
              <Users className="game-mode-icon" />
            </div>
            <h3 className="game-mode-title">Play Online</h3>
            <p className="game-mode-description">Challenge a real player in our matchmaking system</p>
            <button onClick={() => handleStartGame("online")} className="game-mode-button online-button">
              Find Opponent
            </button>
          </div>

          <div className="game-mode-card">
            <div className="game-mode-icon-container">
              <Bot className="game-mode-icon" />
            </div>
            <h3 className="game-mode-title">Play with Bot</h3>
            <p className="game-mode-description">Practice against our AI opponent</p>
            <button onClick={() => handleStartGame("bot")} className="game-mode-button bot-button">
              Start Game
            </button>
          </div>
        </div>
      </div>
    </div>
  )
}
and this is Loading.jsx:
import "./Loading.css"

export default function Loading() {
  return (
    <div className="loading-page">
      <div className="loading-content">
        <div className="loading-spinner"></div>
        <p className="loading-text">Loading...</p>
      </div>
    </div>
  )
}
and this is MatchmakingPage.jsx:

import { useState, useEffect } from "react"
import { Loader2, Wifi, WifiOff, Users } from "lucide-react"
import { useNavigate } from "react-router-dom"
import { gameApi, generatePlayerFingerprint } from "../services/gameApi"
import "./MatchmakingPage.css"

export default function MatchmakingPage() {
  const navigate = useNavigate()
  const [playerFingerprint] = useState(() => generatePlayerFingerprint())
  const [matchId, setMatchId] = useState(null)
  const [status, setStatus] = useState("searching") // searching, found, error
  const [error, setError] = useState(null)

  useEffect(() => {
    const findMatch = async () => {
      try {
        console.log("🔍 Searching for online match...")
        setStatus("searching")

        const matchData = await gameApi.createMatch("online", playerFingerprint)

        console.log("✅ Match result:", matchData)
        setMatchId(matchData.match_id)

        if (matchData.status === "joined_existing_match") {
          console.log("🎯 Joined existing match, starting game immediately")
          setStatus("found")
          setTimeout(() => {
            navigate(`/ultimatum/game?mode=online&match=${matchData.match_id}`)
          }, 2000)
        } else if (matchData.status === "created_new_match") {
          console.log("⏳ Created new match, waiting for opponent")
          setStatus("waiting")
          // Poll for opponent or use WebSocket to detect when opponent joins
          pollForOpponent(matchData.match_id)
        }
      } catch (error) {
        console.error("❌ Error finding match:", error)
        setError(error.message)
        setStatus("error")
      }
    }

    findMatch()
  }, [navigate, playerFingerprint])

  const pollForOpponent = async (matchId) => {
    const maxAttempts = 30 // 30 seconds
    let attempts = 0

    const poll = async () => {
      try {
        attempts++
        console.log(`🔄 Polling for opponent (attempt ${attempts}/${maxAttempts})`)

        // You could create an endpoint to check if match is ready
        // For now, we'll simulate the waiting period

        if (attempts >= maxAttempts) {
          console.log("⏰ Timeout waiting for opponent")
          setError("No opponent found. Please try again.")
          setStatus("error")
          return
        }

        // Continue polling
        setTimeout(poll, 1000)
      } catch (error) {
        console.error("❌ Error polling for opponent:", error)
        setError("Error while waiting for opponent")
        setStatus("error")
      }
    }

    poll()
  }

  const handleCancel = () => {
    console.log("❌ User cancelled matchmaking")
    navigate("/ultimatum")
  }

  const handleRetry = () => {
    console.log("🔄 Retrying matchmaking")
    setError(null)
    setStatus("searching")
    window.location.reload() // Simple retry by reloading
  }

  return (
    <div className="matchmaking-page">
      <div className="matchmaking-container">
        <div className="matchmaking-header">
          <h1 className="matchmaking-title">Ultimatum Game</h1>
          <p className="matchmaking-subtitle">Finding an opponent for your online match...</p>
        </div>

        <div className="matchmaking-card">
          <div className="matchmaking-icon-container">
            {status === "searching" || status === "waiting" ? (
              <Loader2 className="matchmaking-spinner" />
            ) : status === "found" ? (
              <div className="matchmaking-success">
                <Users className="success-icon" />
              </div>
            ) : (
              <div className="matchmaking-error">
                <WifiOff className="error-icon" />
              </div>
            )}
          </div>

          <h2 className="matchmaking-status-title">
            {status === "searching" && "Searching for Match..."}
            {status === "waiting" && "Waiting for Opponent..."}
            {status === "found" && "Opponent Found!"}
            {status === "error" && "Connection Error"}
          </h2>

          <p className="matchmaking-status-text">
            {status === "searching" && "Looking for available matches or creating a new one..."}
            {status === "waiting" && "Match created! Waiting for another player to join..."}
            {status === "found" && "Match found! Starting game..."}
            {status === "error" && (error || "Something went wrong. Please try again.")}
          </p>

          <div className="matchmaking-info">
            <div className="matchmaking-info-row">
              <span>Your ID:</span>
              <span className="matchmaking-player-id">{playerFingerprint}</span>
            </div>
            {matchId && (
              <div className="matchmaking-info-row">
                <span>Match ID:</span>
                <span className="matchmaking-match-id">{matchId}</span>
              </div>
            )}
            <div className="matchmaking-info-row">
              <span>Status:</span>
              <div className="connection-status">
                {status === "searching" || status === "waiting" ? (
                  <>
                    <Loader2 className="connection-icon connection-connecting" />
                    <span className="connection-connecting">{status === "searching" ? "Searching" : "Waiting"}</span>
                  </>
                ) : status === "found" ? (
                  <>
                    <Wifi className="connection-icon connection-connected" />
                    <span className="connection-connected">Ready</span>
                  </>
                ) : (
                  <>
                    <WifiOff className="connection-icon connection-disconnected" />
                    <span className="connection-disconnected">Error</span>
                  </>
                )}
              </div>
            </div>
          </div>

          <div className="matchmaking-buttons">
            {(status === "searching" || status === "waiting") && (
              <button onClick={handleCancel} className="cancel-button">
                Cancel Search
              </button>
            )}
            {status === "error" && (
              <>
                <button onClick={handleRetry} className="retry-button">
                  Try Again
                </button>
                <button onClick={handleCancel} className="cancel-button">
                  Back to Menu
                </button>
              </>
            )}
          </div>
        </div>
      </div>
    </div>
  )
}
and this is PayoffsTable.jsx:
// //  src/components/PayoffsTable.jsx
// import "./PayoffsTable.css";

// /** how many rounds we play **/
// const TOTAL_ROUNDS = 25;

// /**
//  * history example
//  * [
//  *   { roundNumber : 1, player1Offer : 30, player2Offer : 40 },
//  *   { roundNumber : 2, player1Offer : 25, player2Offer : 25 },
//  *   ...
//  * ]
//  */
// export default function PayoffsTable({ history }) {
//   const rounds = Array.from({ length: TOTAL_ROUNDS }, (_, i) => i + 1);

//   /** returns the *offer* for <player> in <round>, or "" if that round not played yet */
//   const offer = (round, player) => {
//     const rec = history.find(h => h.roundNumber === round);
//     if (!rec) return "";
//     return player === 1 ? rec.player1Offer ?? "" : rec.player2Offer ?? "";
//   };

//   return (
//     <>
//       <h3 className="payoffs-title">Payoffs Table</h3>

//       <div className="payoffs-wrapper">
//         <table className="payoffs-table">
//           <thead>
//             <tr>
//               <th className="player-col">Player</th>
//               {rounds.map(r => (
//                 <th key={r}>{r}</th>
//               ))}
//             </tr>
//           </thead>

//           <tbody>
//             {[1, 2].map(p => (
//               <tr key={p}>
//                 <td className="player-label">{`Player ${p}`}</td>
//                 {rounds.map(r => (
//                   <td key={r}>{offer(r, p)}</td>
//                 ))}
//               </tr>
//             ))}
//           </tbody>
//         </table>
//       </div>
//     </>
//   );
// }
import "./PayoffsTable.css"

const TOTAL_ROUNDS = 25

export default function PayoffsTable({ history }) {
  console.log("📊 PayoffsTable received history:", history)

  const rounds = Array.from({ length: TOTAL_ROUNDS }, (_, i) => i + 1)

  const getRoundData = (roundNumber) => {
    const roundData = history.find((h) => h.roundNumber === roundNumber)
    console.log(`📊 Round ${roundNumber} data:`, roundData)
    return roundData
  }

  const getPlayerOffer = (roundNumber, playerNumber) => {
    const roundData = getRoundData(roundNumber)
    if (!roundData) return ""

    // Check if this round data has the offer information
    if (roundData.offer !== undefined && roundData.proposerFingerprint) {
      // This is the new format from WebSocket
      return roundData.proposerFingerprint.includes(`player${playerNumber}`) ? roundData.offer : ""
    }

    // Fallback to old format
    return playerNumber === 1 ? (roundData.player1Offer ?? "") : (roundData.player2Offer ?? "")
  }

  const getPlayerEarnings = (roundNumber, playerNumber) => {
    const roundData = getRoundData(roundNumber)
    if (!roundData) return ""

    // New format from WebSocket
    if (roundData.player1Earned !== undefined) {
      return playerNumber === 1 ? roundData.player1Earned : roundData.player2Earned
    }

    // Calculate from offer and response
    if (roundData.offer !== undefined && roundData.response) {
      const accepted = roundData.response === "accept"
      if (!accepted) return 0

      // Determine if this player was proposer or responder
      const wasProposer = roundData.proposerFingerprint?.includes(`player${playerNumber}`)
      return wasProposer ? 100 - roundData.offer : roundData.offer
    }

    return ""
  }

  return (
    <>
      <h3 className="payoffs-title">Game History</h3>

      <div className="payoffs-wrapper">
        <table className="payoffs-table">
          <thead>
            <tr>
              <th className="player-col">Round</th>
              {rounds.map((r) => (
                <th key={r} className="round-col">
                  {r}
                </th>
              ))}
            </tr>
          </thead>

          <tbody>
            <tr>
              <td className="player-label">P1 Offer</td>
              {rounds.map((r) => (
                <td key={r} className="offer-cell">
                  {getPlayerOffer(r, 1)}
                </td>
              ))}
            </tr>
            <tr>
              <td className="player-label">P2 Offer</td>
              {rounds.map((r) => (
                <td key={r} className="offer-cell">
                  {getPlayerOffer(r, 2)}
                </td>
              ))}
            </tr>
            <tr>
              <td className="player-label">P1 Earned</td>
              {rounds.map((r) => (
                <td key={r} className="earnings-cell">
                  {getPlayerEarnings(r, 1)}
                </td>
              ))}
            </tr>
            <tr>
              <td className="player-label">P2 Earned</td>
              {rounds.map((r) => (
                <td key={r} className="earnings-cell">
                  {getPlayerEarnings(r, 2)}
                </td>
              ))}
            </tr>
          </tbody>
        </table>
      </div>
    </>
  )
}
and this is RootLayout.jsxL
export default function RootLayout({ children }) {
    return <div className="min-h-screen">{children}</div>
  }
  and this is UltimatumApp.jsx:
  "use client"

import { useState } from "react"
import HomePage from "./HomePage"
import MatchmakingPage from "./MatchmakingPage"
import GamePage from "./GamePage"
import Loading from "./Loading"

export default function UltimatumApp() {
  const [currentPage, setCurrentPage] = useState("home") // 'home' | 'matchmaking' | 'game' | 'loading'
  const [gameMode, setGameMode] = useState("online") // 'online' | 'bot'

  const handleStartGame = (mode) => {
    setGameMode(mode)
    if (mode === "online") {
      setCurrentPage("matchmaking")
    } else {
      setCurrentPage("game")
    }
  }

  const handleGameFound = () => {
    setCurrentPage("game")
  }

  const handleCancelMatchmaking = () => {
    setCurrentPage("home")
  }

  const handleGameEnd = () => {
    if (gameMode === "online") {
      setCurrentPage("matchmaking")
    } else {
      setCurrentPage("home")
    }
  }

  const handleBackToMenu = () => {
    setCurrentPage("home")
  }

  const renderCurrentPage = () => {
    switch (currentPage) {
      case "home":
        return <HomePage onStartGame={handleStartGame} />
      case "matchmaking":
        return <MatchmakingPage onGameFound={handleGameFound} onCancel={handleCancelMatchmaking} />
      case "game":
        return <GamePage gameMode={gameMode} onGameEnd={handleGameEnd} onBackToMenu={handleBackToMenu} />
      case "loading":
        return <Loading />
      default:
        return <HomePage onStartGame={handleStartGame} />
    }
  }

  return <div className="ultimatum-app">{renderCurrentPage()}</div>
}
and this is src/services/gameApi.js:
const API_BASE_URL = "http://localhost:8001/api/ultimatum"

export const gameApi = {
  async createMatch(gameMode, playerFingerprint) {
    console.log("🎮 Creating match:", { gameMode, playerFingerprint })

    try {
      const response = await fetch(`${API_BASE_URL}/create-match-ultimatum/`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          game_mode: gameMode,
          player_fingerprint: playerFingerprint,
        }),
      })

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`)
      }

      const data = await response.json()
      console.log("✅ Match created/joined:", data)
      return data
    } catch (error) {
      console.error("❌ Error creating match:", error)
      throw error
    }
  },

  async getMatchStats(matchId) {
    console.log("📊 Getting match stats for:", matchId)

    try {
      const response = await fetch(`${API_BASE_URL}/match-stats/${matchId}/`)

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`)
      }

      const data = await response.json()
      console.log("📊 Match stats:", data)
      return data
    } catch (error) {
      console.error("❌ Error getting match stats:", error)
      throw error
    }
  },

  async getMatchHistory(matchId) {
    console.log("📜 Getting match history for:", matchId)

    try {
      const response = await fetch(`${API_BASE_URL}/match-history/${matchId}/`)

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`)
      }

      const data = await response.json()
      console.log("📜 Match history:", data)
      return data
    } catch (error) {
      console.error("❌ Error getting match history:", error)
      throw error
    }
  },
}

// Generate a unique player fingerprint
export const generatePlayerFingerprint = () => {
  const timestamp = Date.now()
  const random = Math.random().toString(36).substring(2, 15)
  const fingerprint = `player_${timestamp}_${random}`
  console.log("👤 Generated player fingerprint:", fingerprint)
  return fingerprint
}
and this is src/hooks/useWebSocket.js:

import { useState, useEffect, useRef, useCallback } from "react"

export const useWebSocket = (matchId, playerFingerprint) => {
  const [socket, setSocket] = useState(null)
  const [gameState, setGameState] = useState(null)
  const [connectionStatus, setConnectionStatus] = useState("disconnected")
  const [error, setError] = useState(null)
  const reconnectTimeoutRef = useRef(null)
  const reconnectAttemptsRef = useRef(0)
  const maxReconnectAttempts = 5

  const connect = useCallback(() => {
    if (!matchId || !playerFingerprint) {
      console.log("❌ Cannot connect: missing matchId or playerFingerprint")
      return
    }

    try {
      const wsUrl = `ws://localhost:8001/ws/ultimatum-game/${matchId}/`
      console.log("🔌 Connecting to WebSocket:", wsUrl)
      console.log("👤 Player fingerprint:", playerFingerprint)

      const ws = new WebSocket(wsUrl)

      ws.onopen = () => {
        console.log("✅ WebSocket connected successfully")
        setConnectionStatus("connected")
        setError(null)
        reconnectAttemptsRef.current = 0

        // Join the game immediately after connection
        const joinMessage = {
          action: "join",
          player_fingerprint: playerFingerprint,
        }
        console.log("📤 Sending join message:", joinMessage)
        ws.send(JSON.stringify(joinMessage))
      }

      ws.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data)
          console.log("📥 Received WebSocket message:", data)

          if (data.error) {
            console.error("❌ Server error:", data.error)
            setError(data.error)
            return
          }

          if (data.game_state) {
            console.log("🎮 Game state update:", data.game_state)
            setGameState(data.game_state)
          }

          if (data.game_over) {
            console.log("🏁 Game over:", data)
            setGameState((prev) => ({
              ...prev,
              gameOver: true,
              player1Score: data.player1_score,
              player2Score: data.player2_score,
            }))
          }

          if (data.game_aborted) {
            console.log("⚠️ Game aborted:", data.message)
            setError(data.message)
          }

          if (data.action) {
            console.log("🎯 Player action:", data)
            // Handle specific player actions (offers, responses)
            setGameState((prev) => {
              if (!prev) return prev

              const updated = { ...prev }

              if (data.action === "make_offer") {
                updated.currentRoundState = {
                  ...updated.currentRoundState,
                  offerMade: true,
                  offer: data.offer,
                }
                console.log("💰 Offer made:", data.offer, "by player:", data.player_fingerprint)
              }

              if (data.action === "respond_to_offer") {
                updated.currentRoundState = {
                  ...updated.currentRoundState,
                  responseMade: true,
                  response: data.response,
                }
                console.log("🤔 Response made:", data.response, "by player:", data.player_fingerprint)
              }

              return updated
            })
          }
        } catch (err) {
          console.error("❌ Error parsing WebSocket message:", err, event.data)
        }
      }

      ws.onclose = (event) => {
        console.log("🔌 WebSocket closed:", event.code, event.reason)
        setConnectionStatus("disconnected")
        setSocket(null)

        // Attempt to reconnect if not a normal closure
        if (event.code !== 1000 && reconnectAttemptsRef.current < maxReconnectAttempts) {
          const delay = Math.min(1000 * Math.pow(2, reconnectAttemptsRef.current), 10000)
          console.log(
            `🔄 Attempting to reconnect in ${delay}ms (attempt ${reconnectAttemptsRef.current + 1}/${maxReconnectAttempts})`,
          )

          reconnectTimeoutRef.current = setTimeout(() => {
            reconnectAttemptsRef.current++
            connect()
          }, delay)
        }
      }

      ws.onerror = (error) => {
        console.error("❌ WebSocket error:", error)
        setError("Connection error occurred")
        setConnectionStatus("error")
      }

      setSocket(ws)
      setConnectionStatus("connecting")
    } catch (err) {
      console.error("❌ Failed to create WebSocket connection:", err)
      setError("Failed to connect to game server")
      setConnectionStatus("error")
    }
  }, [matchId, playerFingerprint])

  const disconnect = useCallback(() => {
    if (reconnectTimeoutRef.current) {
      clearTimeout(reconnectTimeoutRef.current)
    }
    if (socket) {
      console.log("🔌 Manually disconnecting WebSocket")
      socket.close(1000, "Manual disconnect")
    }
  }, [socket])

  const sendMessage = useCallback(
    (message) => {
      if (socket && socket.readyState === WebSocket.OPEN) {
        console.log("📤 Sending message:", message)
        socket.send(JSON.stringify(message))
        return true
      } else {
        console.error("❌ Cannot send message: WebSocket not connected")
        setError("Not connected to game server")
        return false
      }
    },
    [socket],
  )

  // Connect when hook is initialized
  useEffect(() => {
    connect()
    return () => {
      disconnect()
    }
  }, [connect, disconnect])

  return {
    socket,
    gameState,
    connectionStatus,
    error,
    sendMessage,
    connect,
    disconnect,
  }
}

so the problem is I wanna link my front end with the backend by using websocket and work correctly can you help me with taht tell me what should I do and please print in console all thing that will help me to see the data and all other thing 
and this is my errors: 👤 Generated player fingerprint: player_1749128638202_fq4fd60j2n9
MatchmakingPage.jsx:127 🔍 Searching for online match...
gameApi.js:5 🎮 Creating match: 
{gameMode: 'online', playerFingerprint: 'player_1749128638202_fq4fd60j2n9'}
gameApi.js:8 
 POST http://localhost:8001/api/ultimatum/create-match-ultimatum/ 500 (Internal Server Error)
createMatch	@	gameApi.js:8
(anonymous)	@	MatchmakingPage.jsx:130
(anonymous)	@	MatchmakingPage.jsx:154
gameApi.js:27 ❌ Error creating match: Error: HTTP error! status: 500
    at Object.createMatch (gameApi.js:20:15)
    at async MatchmakingPage.jsx:130:15
createMatch	@	gameApi.js:27
await in createMatch		
(anonymous)	@	MatchmakingPage.jsx:130
(anonymous)	@	MatchmakingPage.jsx:154
MatchmakingPage.jsx:148 ❌ Error finding match: Error: HTTP error! status: 500
    at Object.createMatch (gameApi.js:20:15)
    at async MatchmakingPage.jsx:130:15
(anonymous)	@	MatchmakingPage.jsx:148
await in (anonymous)		
(anonymous)	@	MatchmakingPage.jsx:154
